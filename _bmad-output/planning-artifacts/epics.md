---
stepsCompleted: [1, 2, 3, 4]
inputDocuments:
  - '_bmad-output/planning-artifacts/prd.md'
  - '_bmad-output/planning-artifacts/architecture.md'
  - '_bmad-output/planning-artifacts/ux-design-specification.md'
lastUpdated: '2026-01-10'
updates:
  - date: '2026-01-10'
    description: 'Added Epic 11 (6 stories), Epic 12 (6 stories), Epic 13 (6 stories) for Navigation Refactor, Enhanced Dashboard, and Version Browser'
  - date: '2026-01-03'
    description: 'Added Epic 9 (7 stories) and Epic 10 (8 stories) for QoL Polish and Advanced Mod Browser'
---

# vintagestory-server - Epic Breakdown

## Overview

This document provides the complete epic and story breakdown for vintagestory-server, decomposing the requirements from the PRD, UX Design, and Architecture requirements into implementable stories.

## Requirements Inventory

### Functional Requirements

**Server Lifecycle Management (FR1-5):**

- FR1: Admin can view current server status (running/stopped, uptime, game version)
- FR2: Admin can start the game server
- FR3: Admin can stop the game server gracefully
- FR4: Admin can restart the game server
- FR5: Monitor can view current server status (running/stopped, uptime, game version)

**Console Access (FR6-9):**

- FR6: Admin can view real-time game server console output via WebSocket stream
- FR7: Admin can scroll back through console history buffer
- FR8: Admin can send commands to the game server console
- FR9: Console access is restricted to Admin role only (sensitive data)

**Mod Management (FR10-17):**

- FR10: Admin can view list of installed mods with version and compatibility status
- FR11: Admin can install a mod by entering its slug
- FR12: System validates mod compatibility against current game version before installation
- FR13: System displays warning when mod is not explicitly compatible with current game version
- FR14: Admin can enable an installed mod
- FR15: Admin can disable an installed mod
- FR16: Admin can remove an installed mod
- FR17: Monitor can view list of installed mods (read-only)

**Game Configuration (FR18-22):**

- FR18: Admin can view list of game configuration files
- FR19: Admin can read contents of a game configuration file
- FR20: Admin can edit and save game configuration files
- FR21: Monitor can view list of game configuration files (read-only)
- FR22: Monitor can read contents of game configuration files (read-only)

**Settings Management (FR23-26):**

- FR23: Admin can view server management settings (server name, whitelist mode, etc.)
- FR24: Admin can update server management settings
- FR25: Admin can view player whitelist
- FR26: Admin can add/remove players from whitelist

**Health & Observability (FR27-30):**

- FR27: System exposes health check endpoint (`/healthz`) without authentication
- FR28: System exposes readiness check endpoint (`/readyz`) without authentication
- FR29: Health endpoints report game server process status (running/stopped)
- FR30: System exposes metrics endpoint (`/metrics`) without authentication (POST-MVP)

**Authentication & Authorization (FR31-37):**

- FR31: Protected API endpoints require valid API key via `X-API-Key` header
- FR32: System supports Monitor API keys with read-only access to non-sensitive data
- FR33: System supports Admin API keys with full access including console and write operations
- FR34: Console stream and history are restricted to Admin role (sensitive data protection)
- FR35: Write operations are restricted to Admin role
- FR36: System returns 401 Unauthorized for missing or invalid API key
- FR37: System returns 403 Forbidden when key lacks permission for requested operation

**Deployment & Setup (FR38-39):**

- FR38: System can be deployed via docker-compose with minimal configuration
- FR39: System configuration is provided via environment variables

### NonFunctional Requirements

**Performance (NFR1-3):**

- NFR1: Console output appears in web UI within 1 second of being generated by game server
- NFR2: WebSocket preferred for real-time streaming; polling at 1-second intervals is acceptable fallback
- NFR3: API endpoints under local control respond within 500ms; external API calls may take longer with progress indication

**Security (NFR4-7):**

- NFR4: API keys are stored securely and never logged in plaintext
- NFR5: TLS termination is out of scope for MVP; users requiring HTTPS must provide a reverse proxy
- NFR6: Console history buffer does not persist to disk (sensitive data protection)
- NFR7: Failed authentication attempts are logged for security monitoring

**Reliability (NFR8-10):**

- NFR8: Management API remains available when game server is stopped or crashed
- NFR9: System recovers gracefully from game server process crashes without requiring restart
- NFR10: WebSocket disconnections reconnect automatically without losing significant console history

**Integration (NFR11-13):**

- NFR11: System gracefully handles VintageStory mod API unavailability (cached data, clear error messages)
- NFR12: Mod installation failures due to network issues are reported clearly to user
- NFR13: System does not require external network access for core functionality (mod management requires it)

**Observability (NFR14-16):**

- NFR14: API server logs are structured (JSON) for easy parsing; game server logs remain in their native format
- NFR15: Health endpoints differentiate between "API healthy" and "game server healthy"
- NFR16: Errors include sufficient context for debugging without exposing sensitive data

### Additional Requirements

**From Architecture - Starter Template:**

- Project uses mise for development environment (Python 3.13, uv, Bun)
- Backend: uv + FastAPI pattern with httpx, pydantic-settings, structlog
- Frontend: Vite + React 19.2 + TypeScript + shadcn/ui + Tailwind CSS v4
- Project initialization should be the first implementation story

**From Architecture - Infrastructure:**

- Single container deployment (API + game server in same container) for simplified deployment
- Base image: `mcr.microsoft.com/dotnet/runtime:8.0.22-noble-amd64` (Ubuntu Noble + .NET 8 + Python 3.12)
- Single volume mount at `/data` for all persistence
- Atomic file writes for state persistence (temp file + rename pattern)
- Docker registry: `ghcr.io/craquehouse/vintagestory-server`

**From Architecture - State Management:**

- In-memory state with JSON file sync (`data/state/state.json`)
- WebSocket reconnection with exponential backoff (max 30s, 10 retries)

**From Architecture - API Patterns:**

- API versioning: `/api/v1alpha1`
- Response envelope: `{"status": "ok|error", "data": {...}}`
- JSON field naming: snake_case in API, camelCase in frontend (transform at boundary)
- Error codes centralized in `models/errors.py`

**From Architecture - Frontend Patterns:**

- TanStack Query v5 for server state
- React Context for UI state only (theme, sidebar)
- React Router v7 for navigation
- xterm.js for terminal (Console + Shell modes)
- Catppuccin Mocha/Latte theming via JSON config files

**From UX Design - Server Lifecycle:**

- Server can be in "Not Installed" state with Install button and version input
- Installation progress stages: Downloading → Extracting → Verifying → Complete
- Version mismatch alert when installed differs from configured
- Server states: Not Installed, Installing, Installed (Stopped), Installed (Running), Upgrading, Error

**From UX Design - Pending Restart Pattern:**

- Changes requiring restart tracked server-side (`pendingRestart` state)
- Persistent header banner: "⟳ Restart required · N pending changes · [Restart Now]"
- Two workflows: immediate restart or batch changes

**From UX Design - Components:**

- ServerStatusBadge (6 states with icons)
- CompatibilityBadge (Compatible/Not verified/Incompatible)
- ModLookupInput (accepts slugs or URLs, debounced lookup)
- PendingRestartBanner (header component)
- TerminalView (xterm.js wrapper with Console/Shell tabs)
- ServerInstallCard (empty state for no server)
- InstallProgress (progress bar with stage labels)

**From UX Design - Accessibility:**

- WCAG 2.1 Level AA compliance
- Minimum 44x44px touch targets
- Keyboard navigation via Radix primitives
- ARIA live regions for dynamic content
- Respect `prefers-reduced-motion`

### FR Coverage Map

| FR | Epic | Description |
|----|------|-------------|
| FR1 | Epic 3 | Admin views server status |
| FR2 | Epic 3 | Admin starts server |
| FR3 | Epic 3 | Admin stops server |
| FR4 | Epic 3 | Admin restarts server |
| FR5 | Epic 3 | Monitor views server status |
| FR6 | Epic 4 | Admin views console stream |
| FR7 | Epic 4 | Admin scrolls console history |
| FR8 | Epic 4 | Admin sends console commands |
| FR9 | Epic 4 | Console restricted to Admin |
| FR10 | Epic 5 | Admin views mod list |
| FR11 | Epic 5 | Admin installs mod by slug |
| FR12 | Epic 5 | System validates compatibility |
| FR13 | Epic 5 | System shows compatibility warnings |
| FR14 | Epic 5 | Admin enables mod |
| FR15 | Epic 5 | Admin disables mod |
| FR16 | Epic 5 | Admin removes mod |
| FR17 | Epic 5 | Monitor views mod list |
| FR18 | Epic 6 | Admin views config file list |
| FR19 | Epic 6 | Admin reads config file |
| FR20 | Epic 6 | Admin edits config file |
| FR21 | Epic 6 | Monitor views config file list |
| FR22 | Epic 6 | Monitor reads config file |
| FR23 | Epic 7 | Admin views settings |
| FR24 | Epic 7 | Admin updates settings |
| FR25 | Epic 7 | Admin views whitelist |
| FR26 | Epic 7 | Admin manages whitelist |
| FR27 | Epic 1 | Health endpoint exposed |
| FR28 | Epic 1 | Readiness endpoint exposed |
| FR29 | Epic 1 | Health reports game server status |
| FR31 | Epic 2 | API key authentication |
| FR32 | Epic 2 | Monitor role support |
| FR33 | Epic 2 | Admin role support |
| FR34 | Epic 2 | Console restricted to Admin |
| FR35 | Epic 2 | Writes restricted to Admin |
| FR36 | Epic 2 | 401 for invalid key |
| FR37 | Epic 2 | 403 for insufficient role |
| FR38 | Epic 1 | docker-compose deployment |
| FR39 | Epic 1 | Environment variable config |

**Note:** FR30 (Metrics endpoint) is marked POST-MVP in PRD, not included in MVP epics.

### Post-MVP FR Coverage Map

| FR | Epic | Description |
|----|------|-------------|
| FR40 | Epic 9 | Secure WebSocket token auth |
| FR41 | Epic 9 | Short-lived token validation |
| FR42 | Epic 9 | Auto-create directories on startup |
| FR43 | Epic 9 | Log directory creation |
| FR44 | Epic 9 | Cache eviction strategy |
| FR45 | Epic 9 | Configurable cache limits |
| FR46 | Epic 9 | Log cache eviction events |
| FR47 | Epic 9 | Debug logging throughout services |
| FR48 | Epic 9 | Toggle debug via env var |
| FR49 | Epic 9 | Correlation IDs in debug logs |
| FR50 | Epic 9 | Distinct color for user commands |
| FR51 | Epic 9 | [CMD] prefix for commands |
| FR52 | Epic 9 | JSON syntax colorization |
| FR53 | Epic 9 | Distinct colors for JSON types |
| FR54 | Epic 9 | Show all directories in browser |
| FR55 | Epic 9 | Dynamic directory listing |
| FR56 | Epic 10 | Split Mods into tabs |
| FR57 | Epic 10 | Installed tab functionality |
| FR58 | Epic 10 | Browse tab experience |
| FR59 | Epic 10 | Default newest mods |
| FR60 | Epic 10 | Pre-filter compatible mods |
| FR61 | Epic 10 | Immediate content load |
| FR62 | Epic 10 | Keyword search |
| FR63 | Epic 10 | Debounced search |
| FR64 | Epic 10 | Maintain filters during search |
| FR65 | Epic 10 | Filter by side |
| FR66 | Epic 10 | Filter by tags |
| FR67 | Epic 10 | Filter by game version |
| FR68 | Epic 10 | Filter by mod type |
| FR69 | Epic 10 | Combined filters (AND) |
| FR70 | Epic 10 | Display/remove active filters |
| FR71 | Epic 10 | Sort options |
| FR72 | Epic 10 | Default sort: newest |
| FR73 | Epic 10 | Persist sort selection |
| FR74 | Epic 10 | Card display format |
| FR75 | Epic 10 | Compatibility badges on cards |
| FR76 | Epic 10 | Clickable cards to details |
| FR77 | Epic 10 | Full mod detail view |
| FR78 | Epic 10 | Install with version selection |
| FR79 | Epic 10 | Show installed status in detail |
| FR80 | Epic 10 | Pagination support |
| FR81 | Epic 10 | Infinite scroll or pages |
| FR82 | Epic 10 | Maintain position on return |
| FR83 | Epic 10 | Install from browse/detail |
| FR84 | Epic 10 | Show compatibility before install |
| FR85 | Epic 10 | Update UI after install |
| FR86 | Epic 11 | Expandable Game Server sub-navigation |
| FR87 | Epic 11 | Sub-nav order: Version, Settings, Mods, Console |
| FR88 | Epic 11 | Persist expanded/collapsed state |
| FR89 | Epic 11 | Dynamic Installation/Version label |
| FR90 | Epic 11 | Rename Settings to VSManager |
| FR91 | Epic 11 | Mods under Game Server nav |
| FR92 | Epic 11 | Dedicated Console page |
| FR93 | Epic 11 | Dedicated Settings page |
| FR94 | Epic 11 | Version/Installation page |
| FR95 | Epic 11 | Mods at /game-server/mods with redirects |
| FR96 | Epic 11 | Empty state when server not installed |
| FR97 | Epic 11 | Remove install from Dashboard |
| FR98 | Epic 11 | Dashboard link to Version page |
| FR99 | Epic 11 | Default redirect /game-server → /game-server/version |
| FR100 | Epic 12 | Collect API server metrics |
| FR101 | Epic 12 | Collect game server process metrics |
| FR102 | Epic 12 | Configurable metrics interval |
| FR103 | Epic 12 | Historical metrics storage |
| FR104 | Epic 12 | Current metrics API |
| FR105 | Epic 12 | Historical metrics API with time filter |
| FR106 | Epic 12 | Admin-only metrics access |
| FR107 | Epic 12 | Dashboard stat cards |
| FR108 | Epic 12 | Memory card with API/Game breakdown |
| FR109 | Epic 12 | Time-series memory chart |
| FR110 | Epic 12 | Selectable chart time ranges |
| FR111 | Epic 12 | Quick links to Game Server pages |
| FR112 | Epic 12 | Disabled quick links when no server |
| FR113 | Epic 13 | Version list from stable/unstable |
| FR114 | Epic 13 | Channel filter for versions |
| FR115 | Epic 13 | Version card display |
| FR116 | Epic 13 | Version data caching |
| FR117 | Epic 13 | Version cards like mod browser |
| FR118 | Epic 13 | Installed version indicator |
| FR119 | Epic 13 | Latest version badge |
| FR120 | Epic 13 | Version sort by newest |
| FR121 | Epic 13 | Install from version card |
| FR122 | Epic 13 | Install confirmation dialog |
| FR123 | Epic 13 | Upgrade version comparison |
| FR124 | Epic 13 | Downgrade warning |
| FR125 | Epic 13 | Server-running warning |
| FR126 | Epic 13 | Installation progress display |
| FR127 | Epic 13 | Install Latest Stable quick action |
| FR128 | Epic 13 | Update to Latest quick action |

## Epic List

### Epic 1: Project Foundation & Health Monitoring

Developers can set up the project using the defined starter template, and operations teams can verify the system is running via health endpoints. This epic establishes the scaffolding for all future development and provides the first deployable artifact.

**FRs covered:** FR27, FR28, FR29, FR38, FR39

**MVP Scope:**

- Project initialization per Architecture starter template (mise, uv, Bun)
- Backend scaffolding (FastAPI + dependencies)
- Frontend scaffolding (Vite + React + shadcn/ui)
- Health endpoints (`/healthz`, `/readyz`) without authentication
- docker-compose configuration
- Environment variable configuration pattern

---

### Epic 2: Authentication & API Security

API consumers can authenticate with appropriate role-based access, and the system enforces security boundaries between Admin and Monitor roles.

**FRs covered:** FR31, FR32, FR33, FR34, FR35, FR36, FR37

**MVP Scope:**

- API key authentication via `X-API-Key` header
- Admin role with full access
- Monitor role with read-only access to non-sensitive data
- Console access restricted to Admin only
- Proper 401/403 responses
- Security logging for failed auth attempts

---

### Epic 3: Server Lifecycle Management

Admins can install the VintageStory server by version number and control it (start, stop, restart) from the web UI. This is the first "real user value" epic.

**FRs covered:** FR1, FR2, FR3, FR4, FR5

**MVP Scope:**

- Server installation by version number (download tarball, extract, post-install setup)
- Download progress indication
- Server start/stop/restart controls
- Server status display (running/stopped, version, uptime)
- Dashboard with server controls
- ServerStatusBadge component
- ServerInstallCard for empty state

**Post-MVP (deferred):**

- Version switching/upgrade
- Rollback to previous version

---

### Epic 4: Real-Time Console Access

Admins can monitor game server output in real-time and send commands, enabling troubleshooting without container access.

**FRs covered:** FR6, FR7, FR8, FR9

**MVP Scope:**

- WebSocket console streaming
- Console history buffer (in-memory ring buffer)
- Command input to game server
- Admin-only access enforcement
- TerminalView component with xterm.js (Console mode)
- Auto-reconnection with exponential backoff

**Post-MVP (deferred):**

- Shell tab (PTY access)
- Console search

---

### Epic 5: Mod Management

Admins can install, enable/disable, and remove mods via the web UI with automatic compatibility validation. This is the "slug to success" experience - the defining user journey.

**FRs covered:** FR10, FR11, FR12, FR13, FR14, FR15, FR16, FR17

**MVP Scope:**

- Mod list with version and compatibility status
- Install mod by slug (or URL - parsed to slug)
- Compatibility validation against game version
- Compatibility warnings for unverified mods
- Enable/disable mods
- Remove mods
- Monitor read-only access to mod list
- ModLookupInput component
- CompatibilityBadge component
- Pending restart indication

**Post-MVP (deferred):**

- Mod update detection
- One-click updates
- Version switching/rollback

---

### Epic 6: Game Configuration Management

Admins can view and edit game server configuration files through the web UI, completing the "no terminal needed" promise.

**FRs covered:** FR18, FR19, FR20, FR21, FR22

**MVP Scope:**

- List game configuration files
- Read configuration file contents
- Edit and save configuration files (JSON)
- Monitor read-only access
- Config editor component
- Pending restart pattern for config changes

---

### Epic 7: Server Settings & Whitelist Management

Admins can manage server-level settings and control player access via whitelist.

**FRs covered:** FR23, FR24, FR25, FR26

**MVP Scope:**

- View server management settings
- Update settings (server name, whitelist mode, etc.)
- View player whitelist
- Add/remove players from whitelist
- Settings UI page

---

## Epic Summary

| Epic | Title | FRs | User Value |
|------|-------|-----|------------|
| 1 | Project Foundation & Health Monitoring | 5 | Deployable system with health checks |
| 2 | Authentication & API Security | 7 | Secure role-based API access |
| 3 | Server Lifecycle Management | 5 | Install and control game server |
| 4 | Real-Time Console Access | 4 | Monitor and command server in browser |
| 5 | Mod Management | 8 | Install mods by slug with compatibility |
| 6 | Game Configuration Management | 5 | Edit configs without file access |
| 7 | Server Settings & Whitelist | 4 | Manage settings and player access |
| **Total** | | **38** | |

## Dependency Flow

```
Epic 1 (Foundation)
    ↓
Epic 2 (Auth) ←── Required by all protected endpoints
    ↓
Epic 3 (Server Lifecycle) ←── First user value
    ↓
Epic 4 (Console) ←── Requires server to monitor
    ↓
Epic 5 (Mods) ←── Uses console for verification, server for restarts
    ↓
Epic 6 (Config) ←── Uses pending restart pattern
    ↓
Epic 7 (Settings) ←── Final admin capabilities
```

Each epic is standalone once complete and enables future epics without requiring them.

---

## Epic 1: Project Foundation & Health Monitoring

Developers can set up the project using the defined starter template, and operations teams can verify the system is running via health endpoints.

### Story 1.1: Initialize Development Environment and Project Structure

As a **developer**,
I want **a properly configured development environment with project scaffolding**,
So that **I can begin implementing features with consistent tooling across the team**.

**Acceptance Criteria:**

**Given** a fresh clone of the repository
**When** I run `mise trust && mise install`
**Then** Python 3.13, uv, and Bun are installed at the pinned versions
**And** a `.mise.toml` file exists at the project root with tool versions specified

**Given** the development environment is set up
**When** I navigate to the `api/` directory
**Then** a `pyproject.toml` exists with project name `vintagestory-api`
**And** dependencies include `fastapi[standard]`, `httpx`, `pydantic-settings`, `structlog`
**And** dev dependencies include `pytest`, `pytest-asyncio`, `ruff`, `respx`

**Given** the development environment is set up
**When** I navigate to the `web/` directory
**Then** a `package.json` exists with React 19.2 and TypeScript configured
**And** Tailwind CSS v4 is installed and configured
**And** shadcn/ui is initialized with the project's component configuration

**Given** the project structure is initialized
**When** I examine the repository root
**Then** the directory structure matches the Architecture specification
**And** `.gitignore` excludes appropriate files (node_modules, .venv, **pycache**, data/)

---

### Story 1.2: Backend API Skeleton with Health Endpoints

As an **operations engineer**,
I want **health check endpoints that report system status**,
So that **I can configure Kubernetes probes and monitoring systems**.

**Acceptance Criteria:**

**Given** the API server is running
**When** I send a GET request to `/healthz`
**Then** I receive a 200 status code
**And** the response follows the envelope format `{"status": "ok", "data": {...}}`
**And** no authentication is required
*(Covers FR27)*

**Given** the API server is running
**When** I send a GET request to `/readyz`
**Then** I receive a 200 status code when the API is ready to serve requests
**And** the response includes readiness information
**And** no authentication is required
*(Covers FR28)*

**Given** the API server is running
**When** I query the health endpoints
**Then** the response includes game server process status (running/stopped/not_installed)
**And** the API health is reported separately from game server health
*(Covers FR29, NFR15)*

**Given** the API server is running
**When** the game server process is not running
**Then** the API still responds to health checks (API healthy, game stopped)
*(Covers NFR8)*

**Given** any API request is made
**When** the server processes the request
**Then** structured JSON logs are emitted (in production mode)
**And** human-readable logs are emitted (in development mode)
*(Covers NFR14)*

---

### Story 1.3: Frontend Application Shell

As an **administrator**,
I want **a web interface with navigation and theming**,
So that **I can access server management features through a consistent UI**.

**Acceptance Criteria:**

**Given** I navigate to the web application
**When** the page loads
**Then** I see a sidebar with navigation items (Dashboard, Mods, Config, Terminal)
**And** I see a header displaying the server name placeholder
**And** the application uses Catppuccin Mocha theme by default (dark mode)

**Given** I am viewing the application
**When** I click the theme toggle in the header
**Then** the theme switches between Mocha (dark) and Latte (light)
**And** my preference is persisted in localStorage

**Given** I am viewing the application
**When** my system has `prefers-color-scheme: dark` or `light`
**Then** the initial theme respects my system preference (if no stored preference)

**Given** I am on any page
**When** I click a navigation item in the sidebar
**Then** the URL updates to reflect the selected section
**And** the main content area displays the corresponding view
**And** the active navigation item is visually highlighted

**Given** I am viewing the sidebar
**When** I click the collapse button
**Then** the sidebar collapses to icon-only mode (64px)
**And** my collapse preference is persisted in localStorage

**Given** I resize my browser to mobile width (<768px)
**When** the viewport is narrow
**Then** the sidebar is hidden by default
**And** a hamburger menu button appears to toggle the sidebar overlay

---

### Story 1.4: Docker Deployment Configuration

As a **server administrator**,
I want **to deploy the application using docker-compose**,
So that **I can run VintageStory Server Manager with minimal configuration**.

**Acceptance Criteria:**

**Given** I have Docker and docker-compose installed
**When** I run `docker compose up -d` with `docker-compose.yaml`
**Then** the container starts successfully
**And** the web UI is accessible on port 8080
**And** the health endpoints respond correctly
*(Covers FR38)*

**Given** the container is running
**When** I check the container logs
**Then** I see structured startup messages
**And** no errors are present for a clean start

**Given** I set environment variables (`VS_API_KEY_ADMIN`, etc.)
**When** the container starts
**Then** the application reads configuration from environment variables
**And** default values are used for optional unset variables
*(Covers FR39)*

**Given** a `docker-compose.dev.yaml` file exists
**When** I run `docker compose -f docker-compose.dev.yaml up --build`
**Then** the image builds from local source
**And** development defaults are applied (e.g., `VS_DEBUG=true`)

**Given** the container is running
**When** I examine the volume mounts
**Then** `/data` is mounted for persistent storage
**And** the directory structure matches Architecture specification (`/data/server/`, `/data/mods/`, `/data/state/`, etc.)

**Given** I have a `.env.example` file
**When** I review it
**Then** all configurable environment variables are documented with descriptions

---

## Epic 2: Authentication & API Security

API consumers can authenticate with appropriate role-based access, and the system enforces security boundaries between Admin and Monitor roles.

### Story 2.1: API Key Authentication Middleware

As an **API consumer**,
I want **to authenticate using an API key in the request header**,
So that **I can access protected endpoints securely**.

**Acceptance Criteria:**

**Given** I have a valid Admin API key
**When** I send a request with `X-API-Key: <valid-admin-key>` header
**Then** the request is authenticated successfully
**And** my role is identified as Admin
*(Covers FR31, FR33)*

**Given** I have a valid Monitor API key
**When** I send a request with `X-API-Key: <valid-monitor-key>` header
**Then** the request is authenticated successfully
**And** my role is identified as Monitor
*(Covers FR31, FR32)*

**Given** I send a request without an API key
**When** the endpoint requires authentication
**Then** I receive a 401 Unauthorized response
**And** the response body contains `{"status": "error", "error": {"code": "UNAUTHORIZED", "message": "..."}}`
*(Covers FR36)*

**Given** I send a request with an invalid API key
**When** the endpoint requires authentication
**Then** I receive a 401 Unauthorized response
**And** the failed attempt is logged with request context (but not the key value)
*(Covers FR36, NFR7)*

**Given** any authentication attempt occurs
**When** the system processes the request
**Then** API keys are never logged in plaintext
*(Covers NFR4)*

**Given** health endpoints (`/healthz`, `/readyz`)
**When** I send a request without authentication
**Then** the request succeeds (health endpoints remain unauthenticated)

---

### Story 2.2: Role-Based Access Control for API Endpoints

As a **system administrator**,
I want **different API keys to have different permission levels**,
So that **I can grant read-only access to monitoring systems while reserving write access for admins**.

**Acceptance Criteria:**

**Given** I am authenticated as Admin
**When** I attempt any API operation (read or write)
**Then** the operation is permitted
*(Covers FR33)*

**Given** I am authenticated as Monitor
**When** I attempt a read operation on non-sensitive endpoints
**Then** the operation is permitted
*(Covers FR32)*

**Given** I am authenticated as Monitor
**When** I attempt a write operation (POST, PUT, DELETE on protected resources)
**Then** I receive a 403 Forbidden response
**And** the response body contains `{"status": "error", "error": {"code": "FORBIDDEN", "message": "..."}}`
*(Covers FR35, FR37)*

**Given** I am authenticated as Monitor
**When** I attempt to access console endpoints (stream or history)
**Then** I receive a 403 Forbidden response
**And** the error message indicates console access requires Admin role
*(Covers FR34)*

**Given** role permissions are checked
**When** a 403 response is returned
**Then** the response clearly indicates the required role for the operation

---

### Story 2.3: Frontend API Client with Authentication

As a **frontend developer**,
I want **an API client that handles authentication and key transformation**,
So that **all API calls are properly authenticated and response data is correctly formatted**.

**Acceptance Criteria:**

**Given** the frontend application is configured
**When** API calls are made
**Then** the `X-API-Key` header is automatically included from configuration

**Given** the API returns a response with snake_case fields
**When** the API client processes the response
**Then** fields are transformed to camelCase for frontend consumption

**Given** the API returns a 401 Unauthorized response
**When** the frontend receives the error
**Then** an appropriate error state is displayed to the user
**And** the user is informed that authentication failed

**Given** the API returns a 403 Forbidden response
**When** the frontend receives the error
**Then** an appropriate error state is displayed
**And** the user is informed they lack permission for the operation

**Given** TanStack Query is configured
**When** API calls are made
**Then** server state is managed through TanStack Query hooks
**And** client-only state (theme, sidebar) uses React Context

---

## Epic 3: Server Lifecycle Management

Admins can install the VintageStory server by version number and control it (start, stop, restart) from the web UI.

### Story 3.1: Server Installation Service

As an **administrator**,
I want **to install the VintageStory server by providing a version number**,
So that **I can get a game server running without manual file management**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I call `POST /api/v1alpha1/server/install` with `{"version": "1.21.3"}`
**Then** the system downloads the server tarball from the VintageStory CDN
**And** extracts it to `/data/server/`
**And** creates a symlink from `/data/server/Mods` to `/data/mods/`
**And** copies default config if none exists

**Given** a server installation is in progress
**When** I query `GET /api/v1alpha1/server/install/status`
**Then** I receive progress information (stage: downloading/extracting/configuring, percentage if available)

**Given** the download fails (network error, invalid version)
**When** the installation process encounters the error
**Then** the error is reported clearly with actionable message
**And** the system returns to "not installed" state

**Given** the version format is invalid
**When** I attempt installation
**Then** I receive a 400 Bad Request with validation error details

**Given** a server is already installed
**When** I attempt to install again
**Then** I receive an error indicating server already exists (version switching is post-MVP)

---

### Story 3.2: Server Lifecycle Control API

As an **administrator**,
I want **to start, stop, and restart the game server via API**,
So that **I can control the server without container access**.

**Acceptance Criteria:**

**Given** a server is installed and stopped
**When** I call `POST /api/v1alpha1/server/start`
**Then** the game server process starts
**And** the response confirms the action was initiated
*(Covers FR2)*

**Given** a server is running
**When** I call `POST /api/v1alpha1/server/stop`
**Then** the game server receives a graceful shutdown signal
**And** the process terminates cleanly
**And** the response confirms the action was initiated
*(Covers FR3)*

**Given** a server is running
**When** I call `POST /api/v1alpha1/server/restart`
**Then** the server stops gracefully and starts again
**And** the response confirms the restart was initiated
*(Covers FR4)*

**Given** no server is installed
**When** I attempt to start/stop/restart
**Then** I receive a 400 Bad Request indicating no server is installed

**Given** the server process crashes unexpectedly
**When** the API detects the crash
**Then** the server status updates to "stopped" with exit code information
**And** the API remains available and responsive
*(Covers NFR8, NFR9)*

---

### Story 3.3: Server Status API

As an **administrator or monitor**,
I want **to view the current server status**,
So that **I can see if the server is running and its version**.

**Acceptance Criteria:**

**Given** the API is running
**When** I call `GET /api/v1alpha1/server/status` as Admin
**Then** I receive server status including: state (not_installed/stopped/starting/running/stopping), version, uptime (if running)
*(Covers FR1)*

**Given** the API is running
**When** I call `GET /api/v1alpha1/server/status` as Monitor
**Then** I receive the same status information (read-only access permitted)
*(Covers FR5)*

**Given** the server is running
**When** I query status
**Then** uptime is calculated from process start time
**And** version is read from the installed server

**Given** the server is not installed
**When** I query status
**Then** state is "not_installed"
**And** version and uptime are null

---

### Story 3.4: Dashboard with Server Controls UI

As an **administrator**,
I want **a dashboard showing server status with control buttons**,
So that **I can monitor and control the server from the web interface**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I view the Dashboard
**Then** I see the ServerInstallCard with version input and "Install Server" button
**And** server control buttons (Start/Stop/Restart) are not visible

**Given** a server installation is in progress
**When** I view the Dashboard
**Then** I see a progress indicator with current stage and percentage
**And** the install button is disabled

**Given** a server is installed and stopped
**When** I view the Dashboard
**Then** I see the ServerStatusBadge showing "Stopped" (red)
**And** server version is displayed
**And** "Start" button is enabled
**And** "Stop" and "Restart" buttons are disabled

**Given** a server is running
**When** I view the Dashboard
**Then** I see the ServerStatusBadge showing "Running" (green)
**And** server version and uptime are displayed
**And** "Stop" and "Restart" buttons are enabled
**And** "Start" button is disabled

**Given** I click a server control button
**When** the action is in progress
**Then** the button shows a loading state
**And** a toast notification appears on success or failure

**Given** the server state changes
**When** the Dashboard is open
**Then** the status updates automatically without page refresh (TanStack Query polling or refetch)

---

## Epic 4: Real-Time Console Access

Admins can monitor game server output in real-time and send commands, enabling troubleshooting without container access.

### Story 4.1: Console Buffer Service

As a **backend developer**,
I want **an in-memory ring buffer that captures game server output**,
So that **console history is available for streaming and retrieval**.

**Acceptance Criteria:**

**Given** the game server is running
**When** it produces stdout/stderr output
**Then** the output is captured and stored in the ring buffer
**And** timestamps are added to each line

**Given** the ring buffer has a configured size (default 10,000 lines)
**When** new output exceeds the buffer capacity
**Then** the oldest lines are discarded (FIFO)

**Given** the console buffer contains data
**When** the API server restarts
**Then** the buffer is empty (in-memory only, no disk persistence)
*(Covers NFR6)*

**Given** the game server crashes or stops
**When** the admin queries console history
**Then** the buffer contents up to the crash are preserved
**And** available for troubleshooting

---

### Story 4.2: WebSocket Console Streaming

As an **administrator**,
I want **to receive real-time console output via WebSocket**,
So that **I can monitor server activity as it happens**.

**Acceptance Criteria:**

**Given** I am authenticated as Admin
**When** I connect to `ws://host/api/v1alpha1/console` with `?api_key=<admin-key>`
**Then** the WebSocket connection is established
**And** I begin receiving console output in real-time
*(Covers FR6)*

**Given** I am connected to the console WebSocket
**When** the game server produces output
**Then** I receive the output within 1 second
*(Covers NFR1)*

**Given** I connect to the console WebSocket
**When** the connection is established
**Then** I receive the recent buffer history (configurable, e.g., last 100 lines)
*(Covers FR7)*

**Given** I am authenticated as Monitor
**When** I attempt to connect to the console WebSocket
**Then** the connection is rejected with 403 Forbidden
*(Covers FR9)*

**Given** I have no API key or an invalid key
**When** I attempt to connect to the console WebSocket
**Then** the connection is rejected with 401 Unauthorized

**Given** the WebSocket connection is lost
**When** the client reconnects
**Then** recent buffer history is sent to fill the gap

---

### Story 4.3: Console Command Input

As an **administrator**,
I want **to send commands to the game server through the console**,
So that **I can interact with the server without container access**.

**Acceptance Criteria:**

**Given** I am connected to the console WebSocket as Admin
**When** I send a message with type "command" and content "/help"
**Then** the command is written to the game server's stdin
**And** the command response appears in the console stream
*(Covers FR8)*

**Given** I send a command
**When** the server processes it
**Then** my sent command is echoed back (or marked) in the stream for confirmation

**Given** the game server is not running
**When** I attempt to send a command
**Then** I receive an error message indicating the server is stopped

**Given** I am authenticated as Monitor
**When** I attempt to send a command via any mechanism
**Then** the request is rejected with 403 Forbidden
*(Covers FR9)*

---

### Story 4.4: Terminal View Component

As an **administrator**,
I want **a terminal interface in the web UI showing console output**,
So that **I can view and interact with the server console visually**.

**Acceptance Criteria:**

**Given** I navigate to the Terminal page as Admin
**When** the page loads
**Then** I see an xterm.js terminal component
**And** it connects to the console WebSocket automatically
**And** displays incoming console output with Catppuccin theming

**Given** the terminal is connected
**When** new console output arrives
**Then** it appears in the terminal view immediately
**And** the terminal auto-scrolls to show new content

**Given** I am viewing the terminal
**When** I scroll up in the terminal
**Then** I can view console history from the buffer
*(Covers FR7)*

**Given** I type in the terminal and press Enter
**When** the command is submitted
**Then** it is sent via the WebSocket command mechanism
**And** I see the command and its response in the terminal
*(Covers FR8)*

**Given** the WebSocket connection is lost
**When** the terminal detects disconnection
**Then** a "Disconnected" indicator is shown
**And** the terminal attempts to reconnect with exponential backoff (max 30s, 10 retries)
*(Covers NFR10)*

**Given** reconnection succeeds
**When** the terminal reconnects
**Then** recent history is loaded to fill the gap
**And** the "Disconnected" indicator is removed

**Given** I am authenticated as Monitor
**When** I navigate to the Terminal page
**Then** I see a message indicating console access requires Admin role
**And** no terminal is displayed

---

## Epic 5: Mod Management

Admins can install, enable/disable, and remove mods via the web UI with automatic compatibility validation.

### Story 5.0: Epic 5 Technical Preparation

As a **development team**,
I want **to complete technical preparation for Epic 5 (Mod Management)**,
So that **we have updated architecture docs, caching patterns, and refactored tests before implementing mod features**.

**Background:** This preparatory story was defined during the Epic 4 retrospective. Epic 5 introduces external API dependencies and new UI patterns that benefit from upfront research and infrastructure improvements.

**Acceptance Criteria:**

**Given** the architecture documentation is reviewed
**When** I read the architecture.md file
**Then** it reflects current implementation state and any needed updates for Epic 5

**Given** a manual test checklist exists
**When** I review `docs/manual-test-checklist.md`
**Then** it contains smoke tests for Epics 1-4 functionality and placeholders for Epic 5

**Given** the mod API patterns are verified
**When** I review `agentdocs/modstoryapi.md`
**Then** it contains current API patterns with working examples verified against the live API

**Given** pending restart pattern research is complete
**When** I review the research findings
**Then** it documents the UI pattern for tracking changes requiring server restart

**Given** caching strategy research is complete
**When** I review the caching documentation
**Then** it covers artifact caching (server tarballs) and API response caching (mod data, TTL-based)

**Given** large test files are refactored
**When** I examine `api/tests/`
**Then** `test_console.py` and `test_server.py` are split into focused modules

**Tasks:**

- [ ] Task 1: Architecture doc review and update
- [ ] Task 2: Manual test checklist creation (`docs/manual-test-checklist.md`)
- [ ] Task 3: Mod API integration patterns verification
- [ ] Task 4: Pending restart pattern research
- [ ] Task 5: Caching strategy research (artifacts + API responses)
- [ ] Task 6: Refactor large test files into focused modules

---

### Story 5.1: Mod Service and State Management

As a **backend developer**,
I want **a service that tracks installed mods and their state**,
So that **mod information is persisted and available to the API**.

**Acceptance Criteria:**

**Given** mods are installed in `/data/mods/`
**When** the API starts or rescans
**Then** the mod service discovers all `.zip` files in the mods directory
**And** extracts mod metadata (modid, version, name) from `modinfo.json`

**Given** a mod's enabled/disabled state changes
**When** the state is updated
**Then** the change is persisted to `/data/state/state.json` (atomic write)
**And** a pending restart flag is set if the server is running

**Given** state persistence fails
**When** an atomic write is attempted
**Then** the temp file is written first, then renamed (prevents corruption)

---

### Story 5.2: Mod Installation API

As an **administrator**,
I want **to install a mod by entering its slug**,
So that **I don't need to manually download and copy mod files**.

**Acceptance Criteria:**

**Given** I call `POST /api/v1alpha1/mods` with `{"slug": "smithingplus"}`
**When** the mod exists on mods.vintagestory.at
**Then** the latest release is downloaded to `/data/mods/`
**And** the mod appears in the installed mods list
*(Covers FR11)*

**Given** I provide a full URL instead of a slug
**When** I call the install endpoint with `{"slug": "https://mods.vintagestory.at/smithingplus"}`
**Then** the slug is extracted from the URL and installation proceeds

**Given** the mod slug does not exist
**When** I attempt installation
**Then** I receive a 404 error with message "Mod not found"

**Given** the VintageStory mod API is unavailable
**When** I attempt installation
**Then** I receive a 502 error with clear message about external API failure
*(Covers NFR11)*

**Given** the download fails mid-transfer
**When** the error occurs
**Then** partial files are cleaned up
**And** a clear error message is returned
*(Covers NFR12)*

---

### Story 5.3: Mod Compatibility Validation

As an **administrator**,
I want **to see mod compatibility before installation**,
So that **I can make informed decisions about installing mods**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods/lookup/{slug}`
**When** the mod exists
**Then** I receive mod details including: name, description, latest version, and compatibility status

**Given** the installed game server version is 1.21.3
**When** I look up a mod with release tagged for "1.21.3"
**Then** compatibility status is "compatible"
*(Covers FR12)*

**Given** the installed game server version is 1.21.3
**When** I look up a mod with latest release tagged for "1.21.0"
**Then** compatibility status is "not_verified"
**And** a warning message indicates the mod wasn't explicitly tested for this version
*(Covers FR13)*

**Given** the installed game server version is 1.21.3
**When** I look up a mod with release tagged for "1.20.x" only
**Then** compatibility status is "incompatible"
**And** a warning message indicates version mismatch

**Given** I install a mod with "not_verified" or "incompatible" status
**When** the installation completes
**Then** the mod is installed (user made informed choice)
**And** the compatibility status is stored with the mod record

---

### Story 5.4: Mod Enable/Disable and Remove API

As an **administrator**,
I want **to enable, disable, and remove installed mods**,
So that **I can manage which mods are active without deleting files**.

**Acceptance Criteria:**

**Given** a mod is installed and enabled
**When** I call `POST /api/v1alpha1/mods/{slug}/disable`
**Then** the mod is marked as disabled in state
**And** the mod file is moved/renamed to indicate disabled status (e.g., `.disabled` suffix)
**And** a pending restart flag is set
*(Covers FR15)*

**Given** a mod is installed and disabled
**When** I call `POST /api/v1alpha1/mods/{slug}/enable`
**Then** the mod is marked as enabled in state
**And** the mod file is restored to active status
**And** a pending restart flag is set
*(Covers FR14)*

**Given** a mod is installed
**When** I call `DELETE /api/v1alpha1/mods/{slug}`
**Then** the mod file is deleted from `/data/mods/`
**And** the mod is removed from state
**And** a pending restart flag is set
*(Covers FR16)*

**Given** the mod slug doesn't exist in installed mods
**When** I attempt enable/disable/remove
**Then** I receive a 404 error

---

### Story 5.5: Mod List API

As an **administrator or monitor**,
I want **to view a list of installed mods with their status**,
So that **I can see what mods are installed and their compatibility**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods` as Admin
**When** mods are installed
**Then** I receive a list of installed mods with: slug, name, version, enabled status, compatibility status
*(Covers FR10)*

**Given** I call `GET /api/v1alpha1/mods` as Monitor
**When** mods are installed
**Then** I receive the same list (read-only access permitted)
*(Covers FR17)*

**Given** no mods are installed
**When** I query the mod list
**Then** I receive an empty array

**Given** the pending restart flag is set
**When** I query the mod list
**Then** the response includes `pending_restart: true` indicator

---

### Story 5.6: Mod Management UI

As an **administrator**,
I want **a web interface for managing mods**,
So that **I can install, view, and manage mods visually**.

**Acceptance Criteria:**

**Given** I navigate to the Mods page
**When** the page loads
**Then** I see a ModLookupInput field with placeholder "Enter mod slug or paste URL"
**And** I see a table of installed mods (or empty state if none)

**Given** I type a mod slug in the input
**When** I stop typing (300ms debounce)
**Then** a lookup request is made
**And** mod details appear in a preview card below the input

**Given** the mod lookup returns results
**When** I view the preview card
**Then** I see mod name, description, and CompatibilityBadge (green/yellow/red)
**And** an "Install" button is available

**Given** I click "Install" on a compatible mod
**When** installation completes
**Then** a success toast appears
**And** the mod appears in the installed mods table
**And** the pending restart banner appears in the header

**Given** I click "Install" on an incompatible mod
**When** I click the button
**Then** a warning dialog appears asking for confirmation
**And** I can choose to proceed or cancel

**Given** the mods table is displayed
**When** I view an installed mod row
**Then** I see: mod name, installed version, compatibility badge, enabled/disabled toggle, remove button

**Given** I toggle a mod's enabled state
**When** the toggle is clicked
**Then** the state updates optimistically
**And** a toast confirms success or shows error
**And** pending restart indicator updates

**Given** I click the remove button on a mod
**When** the confirmation dialog appears and I confirm
**Then** the mod is removed from the list
**And** a success toast appears

---

## Epic 6: Game Configuration Management

Admins can configure game server settings through the web UI using console commands for live updates. The Console tab is renamed to GameServer and includes both console output and a configuration panel side-by-side. API operational settings are managed separately in a new Settings tab.

**Architectural Pivot (2025-12-30):** Original file-editing approach replaced with console command pattern. VintageStory server handles JSON persistence automatically when settings are changed via `/serverconfig` commands.

**Key Decisions:**
- `/config/game` - Game server settings (console commands for live update)
- `/config/api` - API operational settings (auto_start, refresh intervals)
- ConfigInitService - First-run config generation from template + VS_CFG_* env vars
- Console tab → GameServer tab with responsive split layout
- TanStack Table for data lists, Zod + custom hooks for field validation

---

### Story 6.0: Epic 6 Technical Preparation

As a **developer**,
I want **to research VintageStory console commands and create configuration infrastructure**,
So that **subsequent stories have a solid foundation for config management**.

**Acceptance Criteria:**

**Given** we need to understand console command behavior
**When** I research the `/serverconfig` command
**Then** I document which settings support live update vs require restart
**And** I verify that console changes persist to serverconfig.json automatically

**Given** we need a reference configuration template
**When** I analyze DarkMatterProductions and VintageStory defaults
**Then** I create `serverconfig-template.json` with sensible defaults
**And** the template includes all common settings with documentation comments removed

**Given** we need to support VS_CFG_* environment variables
**When** I define the environment variable mapping
**Then** I document the complete ENV_VAR_MAP (VS_CFG_SERVER_NAME → ServerName, etc.)
**And** I verify the mapping covers all settings from the reference implementation

**Given** we need TanStack Table for data lists
**When** I add the dependency
**Then** `@tanstack/react-table` is added to web/package.json
**And** a basic table component pattern is documented

**Tasks:**
- [ ] Research `/serverconfig` command - document supported settings
- [ ] Test console command persistence - verify JSON auto-save
- [ ] Create `serverconfig-template.json` from DarkMatterProductions reference
- [ ] Define complete VS_CFG_* → serverconfig.json key mapping
- [ ] Add TanStack Table dependency to web project
- [ ] Update architecture.md with research findings

---

### Story 6.1: ConfigInitService and Template

As an **administrator**,
I want **the server to automatically generate an initial configuration from environment variables**,
So that **I can deploy with custom settings without manual file creation**.

**Acceptance Criteria:**

**Given** the game server is installed but no serverconfig.json exists
**When** the server start is requested
**Then** ConfigInitService generates serverconfig.json from the template
**And** any VS_CFG_* environment variables override template defaults

**Given** VS_CFG_SERVER_NAME is set to "My Custom Server"
**When** ConfigInitService generates the config
**Then** serverconfig.json contains `"ServerName": "My Custom Server"`

**Given** VS_CFG_MAX_CLIENTS is set to "32"
**When** ConfigInitService generates the config
**Then** serverconfig.json contains `"MaxClients": 32` (integer, not string)

**Given** serverconfig.json already exists
**When** the server start is requested
**Then** ConfigInitService does NOT overwrite the existing config
**And** the existing config is used as-is

**Given** an invalid VS_CFG_* value is provided (e.g., VS_CFG_MAX_CLIENTS="abc")
**When** ConfigInitService processes environment variables
**Then** the invalid value is logged as a warning
**And** the template default is used instead

**Tasks:**
- [ ] Create ConfigInitService class with needs_initialization() and initialize_config()
- [ ] Implement ENV_VAR_MAP with type coercion (string, int, bool)
- [ ] Ship serverconfig-template.json in api package
- [ ] Integrate with ServerService.start() - call before server launch
- [ ] Add comprehensive tests for env var processing
- [ ] Test atomic write pattern (temp file + rename)

---

### Story 6.2: Game Settings API

As an **administrator**,
I want **to view and update game server settings through the API**,
So that **I can configure the server using console commands for live updates**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/config/game` as Admin or Monitor
**When** serverconfig.json exists
**Then** I receive settings with metadata (key, value, type, live_update, env_managed)
**And** the response includes source_file and last_modified

**Given** I call `POST /api/v1alpha1/config/game/settings/ServerName` with `{"value": "New Name"}`
**When** the game server is running
**Then** the API executes `/serverconfig Name "New Name"` via console
**And** the response includes `method: "console_command"` and `pending_restart: false`

**Given** I call `POST /api/v1alpha1/config/game/settings/Port` with `{"value": 42421}`
**When** the game server is running
**Then** the setting is written to serverconfig.json (Port requires restart)
**And** the response includes `method: "file_update"` and `pending_restart: true`

**Given** I attempt to update a setting managed by VS_CFG_* environment variable
**When** block_env_managed_settings is true (default)
**Then** I receive a 400 error with code SETTING_ENV_MANAGED
**And** the error message identifies the controlling environment variable

**Given** I am authenticated as Monitor
**When** I attempt to POST a setting update
**Then** I receive a 403 Forbidden

**Tasks:**
- [ ] Create GameConfigService with get_settings() and update_setting()
- [ ] Implement LIVE_SETTINGS map with console command templates
- [ ] Add /config/game router with GET and POST endpoints
- [ ] Integrate with ConsoleService for command execution
- [ ] Add pending restart state integration
- [ ] Comprehensive tests for live vs restart-required settings

---

### Story 6.3: API Settings Service

As an **administrator**,
I want **to view and update API operational settings**,
So that **I can configure auto-start, refresh intervals, and environment handling**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/config/api` as Admin
**When** api-settings.json exists (or defaults are used)
**Then** I receive current API settings: auto_start_server, block_env_managed_settings, refresh intervals

**Given** I call `POST /api/v1alpha1/config/api/settings/auto_start_server` with `{"value": true}`
**When** the request is valid
**Then** the setting is saved to api-settings.json
**And** the response confirms the update

**Given** I update mod_list_refresh_interval
**When** the scheduler is running (Epic 7+)
**Then** the job is rescheduled with the new interval

**Given** I am authenticated as Monitor
**When** I call GET /api/v1alpha1/config/api
**Then** I receive a 403 Forbidden (API settings are Admin-only)

**Tasks:**
- [ ] Create ApiSettingsService with get_settings() and update_setting()
- [ ] Define ApiSettings Pydantic model with defaults
- [ ] Implement api-settings.json persistence with atomic writes
- [ ] Add /config/api router with GET and POST endpoints
- [ ] Add setting validation (e.g., intervals must be positive)

---

### Story 6.4: Settings UI

As an **administrator**,
I want **a web interface for managing game and API settings**,
So that **I can configure the server visually and see console command feedback**.

**Acceptance Criteria:**

**Given** I navigate to the GameServer tab as Admin
**When** the page loads on desktop (≥1024px)
**Then** I see Game Config panel on left and Console on right (split view)

**Given** I navigate to the GameServer tab on mobile (<1024px)
**When** the page loads
**Then** I see Console on top and Game Config below (stacked, scrollable)

**Given** I change the ServerName field in Game Config
**When** I blur the field (auto-save)
**Then** the API is called and I see the `/serverconfig` command execute in Console
**And** a success toast appears

**Given** I change a restart-required setting (e.g., Port)
**When** the save completes
**Then** the PendingRestartBanner appears (consistent with mod changes)

**Given** a setting is managed by VS_CFG_* environment variable
**When** I view the setting
**Then** it shows an "Env: VS_CFG_*" badge and the input is disabled

**Given** I navigate to the Settings tab
**When** the page loads
**Then** I see tabs for "API Settings" and "File Manager"
**And** API Settings shows auto_start, env handling, and refresh intervals
**And** File Manager shows a "coming soon" stub

**Tasks:**
- [ ] Rename Console → GameServer in navigation
- [ ] Create GameServerPage with responsive split layout
- [ ] Create GameConfigPanel with SettingGroup and SettingField components
- [ ] Implement useSettingField hook with Zod validation
- [ ] Create SettingsPage with API Settings and File Manager tabs
- [ ] Create ApiSettingsPanel component
- [ ] Add File Manager stub component

---

### Story 6.5: Raw Config Viewer

As an **administrator or monitor**,
I want **read-only access to raw configuration files**,
So that **I can troubleshoot configuration issues**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/config/files` as Admin or Monitor
**When** config files exist in the data directory
**Then** I receive a list of configuration file names

**Given** I call `GET /api/v1alpha1/config/files/serverconfig.json`
**When** the file exists
**Then** I receive the raw JSON content

**Given** I request a file with path traversal (e.g., `../secrets.json`)
**When** the API validates the path
**Then** I receive a 400 error and the request is rejected

**Note:** This story provides the backend for the File Manager UI (stub in 6.4). Full File Manager UI is deferred to a future epic.

**Tasks:**
- [ ] Create /config/files router with list and read endpoints
- [ ] Implement path validation to prevent traversal attacks
- [ ] Add Monitor + Admin role access
- [ ] Add tests for path traversal prevention

---

## Epic 7: APScheduler Integration

The API server can execute periodic background tasks using APScheduler, enabling features like cache refresh and version checking.

**Added (2025-12-30):** New epic for background task scheduling infrastructure.

**Key Decisions:**
- APScheduler with AsyncIOScheduler and MemoryJobStore
- No external dependencies (in-memory job store)
- SchedulerService pattern with lifespan integration
- Job management API for visibility

---

### Story 7.0: Epic 7 Preparation

As a **developer**,
I want **to research APScheduler patterns and async integration**,
So that **subsequent stories have a solid foundation for scheduling**.

**Acceptance Criteria:**

**Given** we need to understand APScheduler async patterns
**When** I research the library
**Then** I document AsyncIOScheduler configuration best practices
**And** I verify compatibility with our FastAPI lifespan pattern

**Given** we need to add APScheduler
**When** I add the dependency
**Then** `apscheduler` is added to api/pyproject.toml
**And** version is pinned appropriately

**Tasks:**
- [ ] Research APScheduler AsyncIOScheduler patterns
- [ ] Add apscheduler dependency to pyproject.toml
- [ ] Document job defaults (coalesce, max_instances, misfire_grace_time)

---

### Story 7.1: SchedulerService

As a **developer**,
I want **a scheduler service that manages periodic background tasks**,
So that **jobs can be added, removed, and monitored**.

**Acceptance Criteria:**

**Given** the API server starts
**When** the lifespan context initializes
**Then** the SchedulerService starts the AsyncIOScheduler
**And** a log entry confirms "scheduler_started"

**Given** the API server shuts down
**When** the lifespan context exits
**Then** the SchedulerService stops the scheduler gracefully
**And** running jobs complete before shutdown

**Given** I need to add an interval job
**When** I call scheduler.add_interval_job(func, seconds, job_id)
**Then** the job is registered and will execute at the specified interval

**Given** I need to add a cron job
**When** I call scheduler.add_cron_job(func, cron_expression, job_id)
**Then** the job is registered with the cron schedule

**Tasks:**
- [ ] Create SchedulerService class with start/shutdown methods
- [ ] Implement add_interval_job and add_cron_job methods
- [ ] Integrate with FastAPI lifespan in main.py
- [ ] Add structured logging for scheduler events
- [ ] Add tests for scheduler lifecycle

---

### Story 7.2: Job Management API

As an **administrator**,
I want **to view and manage scheduled jobs through the API**,
So that **I can monitor background task status**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/jobs` as Admin
**When** jobs are registered
**Then** I receive a list of jobs with: id, next_run_time, interval/cron, last_run_status

**Given** I call `DELETE /api/v1alpha1/jobs/{job_id}` as Admin
**When** the job exists
**Then** the job is removed from the scheduler
**And** the response confirms deletion

**Given** I am authenticated as Monitor
**When** I call GET /api/v1alpha1/jobs
**Then** I receive a 403 Forbidden (job management is Admin-only)

**Tasks:**
- [ ] Create /jobs router with list and delete endpoints
- [ ] Implement job serialization (id, schedule, status)
- [ ] Add Admin-only authorization
- [ ] Add tests for job API

---

### Story 7.3: Scheduler Health

As an **operator**,
I want **scheduler status included in health checks**,
So that **I can monitor the background task system**.

**Acceptance Criteria:**

**Given** I call `GET /healthz`
**When** the scheduler is running
**Then** the response includes `scheduler: { status: "running", job_count: N }`

**Given** the scheduler has failed to start
**When** I call /healthz
**Then** the response includes `scheduler: { status: "stopped" }`

**Tasks:**
- [ ] Add scheduler status to health endpoint
- [ ] Include job count in health response
- [ ] Add tests for scheduler health reporting

---

## Epic 8: Periodic Task Patterns

Initial periodic jobs are implemented using the APScheduler infrastructure, enabling automated cache refresh and version checking.

**Added (2025-12-30):** New epic for implementing periodic jobs.

---

### Story 8.0: Epic 8 Preparation

As a **developer**,
I want **to define job patterns and error handling strategy**,
So that **periodic tasks are implemented consistently**.

**Acceptance Criteria:**

**Given** we need a standard job pattern
**When** I define the template
**Then** jobs follow a consistent structure: try/except, structured logging, no re-raise

**Given** we need job registration patterns
**When** I define the approach
**Then** jobs are registered in a central register_default_jobs() function
**And** registration respects API settings (interval values)

**Tasks:**
- [ ] Define standard job template in architecture
- [ ] Create jobs/ directory structure
- [ ] Implement register_default_jobs() function

---

### Story 8.1: Mod Cache Refresh Job

As an **administrator**,
I want **the mod API cache to refresh automatically**,
So that **mod information stays current without manual intervention**.

**Acceptance Criteria:**

**Given** mod_list_refresh_interval is set to 3600 (1 hour)
**When** the scheduler runs
**Then** the mod cache refresh job executes every hour

**Given** the mod API is unreachable during refresh
**When** the job executes
**Then** the error is logged but the job continues on schedule
**And** stale cache data is preserved

**Given** mod_list_refresh_interval is set to 0
**When** the scheduler starts
**Then** the mod cache refresh job is NOT registered

**Tasks:**
- [ ] Create refresh_mod_cache job function
- [ ] Register job in register_default_jobs()
- [ ] Add error handling and logging
- [ ] Add tests for job execution

---

### Story 8.2: Server Versions Check Job

As an **administrator**,
I want **automatic checks for new VintageStory versions**,
So that **I'm notified when updates are available**.

**Acceptance Criteria:**

**Given** server_versions_refresh_interval is set to 86400 (24 hours)
**When** the scheduler runs
**Then** the version check job executes daily

**Given** a new version is available
**When** the job detects it
**Then** the new version is logged
**And** the version info is available via status API

**Tasks:**
- [ ] Create check_server_versions job function
- [ ] Register job in register_default_jobs()
- [ ] Store latest version info for status API
- [ ] Add tests for version checking

---

### Story 8.3: Job Configuration UI

As an **administrator**,
I want **to view scheduled jobs in the Settings UI**,
So that **I can monitor background task status**.

**Acceptance Criteria:**

**Given** I navigate to the Settings page
**When** the page loads
**Then** I see a "Scheduled Jobs" section showing registered jobs

**Given** jobs are displayed
**When** I view a job
**Then** I see: job name, interval/schedule, next run time, last status

**Tasks:**
- [ ] Add jobs section to SettingsPage
- [ ] Create JobsTable component using TanStack Table
- [ ] Add useJobs query hook
- [ ] Style with badges for status (running, scheduled, failed)

---

## Story Summary

| Epic | Stories | Total |
|------|---------|-------|
| Epic 1: Project Foundation & Health Monitoring | 1.1, 1.2, 1.3, 1.4 | 4 |
| Epic 2: Authentication & API Security | 2.1, 2.2, 2.3 | 3 |
| Epic 3: Server Lifecycle Management | 3.1, 3.2, 3.3, 3.4, 3.5 | 5 |
| Epic 4: Real-Time Console Access | 4.0, 4.1, 4.2, 4.3, 4.4 | 5 |
| Epic 5: Mod Management | 5.0, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6 | 7 |
| Epic 6: Game Configuration Management | 6.0, 6.1, 6.2, 6.3, 6.4, 6.5 | 6 |
| Epic 7: APScheduler Integration | 7.0, 7.1, 7.2, 7.3 | 4 |
| Epic 8: Periodic Task Patterns | 8.0, 8.1, 8.2, 8.3 | 4 |
| Epic 9: Quality of Life Polish Pass | 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7 | 7 |
| Epic 10: Advanced Mod Browser | 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8 | 8 |
| Epic 11: GameServer Navigation Refactor | 11.1, 11.2, 11.3, 11.4, 11.5, 11.6 | 6 |
| Epic 12: Enhanced Dashboard with Server Metrics | 12.1, 12.2, 12.3, 12.4, 12.5, 12.6 | 6 |
| Epic 13: Server Version Browser | 13.0, 13.1, 13.2, 13.3, 13.4, 13.5 | 6 |
| **Total** | | **71** |

---

## Epic 9: Quality of Life Polish Pass

Admins benefit from security improvements, better debugging capabilities, and enhanced UI features that improve daily operations and troubleshooting.

**FRs covered:** FR40, FR41, FR42, FR43, FR44, FR45, FR46, FR47, FR48, FR49, FR50, FR51, FR52, FR53, FR54, FR55

**MVP Scope:**

- Secure WebSocket token authentication (replaces API key in URL)
- Directory auto-creation on startup
- Mod cache eviction strategy
- Debug logging with correlation IDs
- Console command highlighting with [CMD] prefix
- JSON syntax colorization in file viewer
- Dynamic directory listing in file browser

---

### Story 9.1: Secure WebSocket Authentication

As an **administrator**,
I want **WebSocket connections to use secure token authentication**,
So that **my API key is not exposed in URL query parameters**.

**Acceptance Criteria:**

**Given** I need to connect to the console WebSocket
**When** I request a connection token via `POST /api/v1alpha1/auth/ws-token`
**Then** I receive a short-lived token (e.g., 30 second TTL)
**And** the response includes `{"token": "<jwt-or-opaque-token>", "expires_in": 30}`
*(Covers FR40)*

**Given** I have a valid WebSocket token
**When** I connect to `ws://host/api/v1alpha1/console?token=<token>`
**Then** the connection is established successfully
**And** the token is validated server-side
*(Covers FR41)*

**Given** I attempt to connect with an expired token
**When** the token TTL has passed
**Then** the WebSocket connection is rejected with 401

**Given** the frontend needs to connect to the console
**When** the Terminal component mounts
**Then** it first requests a token, then connects with that token
**And** token refresh is handled automatically before expiry

---

### Story 9.2: Directory Auto-Creation on Startup

As an **operator**,
I want **the API server to create required directories on startup**,
So that **I don't encounter errors from missing directories**.

**Acceptance Criteria:**

**Given** the API server starts
**When** expected directories don't exist under `/data/vsmanager/`
**Then** the directories are created: `cache/`, `state/`, `logs/`
*(Covers FR42)*

**Given** directories are created on startup
**When** any directory is created
**Then** a log entry is emitted: `{"event": "directory_created", "path": "..."}`
*(Covers FR43)*

**Given** directories already exist
**When** the API server starts
**Then** no errors occur and no creation logs are emitted

**Given** directory creation fails (permissions issue)
**When** startup encounters the error
**Then** a clear error is logged and startup fails gracefully

---

### Story 9.3: Mod Cache Eviction Strategy

As an **administrator**,
I want **the mod cache to automatically clean up old files**,
So that **disk space is managed without manual intervention**.

**Acceptance Criteria:**

**Given** the mod cache directory exists
**When** total cache size exceeds the configured limit (default 500MB)
**Then** the oldest accessed files are evicted until under limit (LRU strategy)
*(Covers FR44)*

**Given** I set `VS_MOD_CACHE_MAX_SIZE` environment variable
**When** the API server starts
**Then** the cache limit is set to the configured value
*(Covers FR45)*

**Given** cache eviction occurs
**When** files are removed
**Then** log entries are emitted: `{"event": "cache_evicted", "file": "...", "reason": "size_limit"}`
*(Covers FR46)*

**Given** the cache is under the size limit
**When** eviction check runs
**Then** no files are removed

---

### Story 9.4: Debug Logging Infrastructure

As a **developer or operator**,
I want **comprehensive debug logging throughout the API**,
So that **I can troubleshoot issues with detailed request tracing**.

**Acceptance Criteria:**

**Given** `VS_DEBUG=true` is set
**When** API requests are processed
**Then** debug-level logs are emitted for each service layer (router → service → repository)
*(Covers FR47)*

**Given** `VS_DEBUG` is changed at runtime
**When** the environment variable is updated
**Then** debug logging is enabled/disabled without server restart
*(Covers FR48)*

**Given** debug logging is enabled
**When** a request is processed
**Then** all log entries include a correlation ID (`request_id`) for tracing
**And** the correlation ID is consistent across all logs for that request
*(Covers FR49)*

**Given** debug logging is disabled (default)
**When** requests are processed
**Then** only info, warning, and error logs are emitted

---

### Story 9.5: Console Command Highlighting

As an **administrator**,
I want **my commands to be visually distinct in the console**,
So that **I can easily identify what I typed vs server output**.

**Acceptance Criteria:**

**Given** I send a command via the console
**When** the command is echoed in the terminal
**Then** it is displayed in a distinct color (e.g., cyan or yellow)
*(Covers FR50)*

**Given** I send a command via the console
**When** the command appears in the output
**Then** it is prefixed with `[CMD]` marker
*(Covers FR51)*

**Given** server output arrives
**When** it is displayed in the terminal
**Then** it uses the default console color (not the command color)

---

### Story 9.6: JSON Syntax Colorization

As an **administrator**,
I want **JSON files to be syntax-highlighted in the file viewer**,
So that **configuration files are easier to read and understand**.

**Acceptance Criteria:**

**Given** I open a `.json` file in the file viewer
**When** the content is rendered
**Then** syntax colorization is applied
*(Covers FR52)*

**Given** JSON content is displayed
**When** I view the highlighted content
**Then** keys, strings, numbers, booleans, and null values each have distinct colors
*(Covers FR53)*

**Given** I open a non-JSON file
**When** the content is rendered
**Then** no JSON colorization is applied (plain text)

**Given** the JSON file contains invalid JSON
**When** the file is displayed
**Then** it renders as plain text with no colorization errors

---

### Story 9.7: Dynamic File Browser

As an **administrator**,
I want **the file browser to show all directories dynamically**,
So that **I can access ModConfigs, Macros, Playerdata, and other directories**.

**Acceptance Criteria:**

**Given** I open the file browser
**When** the directory listing loads
**Then** all directories under `/data/serverdata/` are displayed
**And** this includes ModConfigs, Macros, Playerdata, and any others present
*(Covers FR54)*

**Given** the file browser lists directories
**When** the list is generated
**Then** it is dynamically discovered from the filesystem (not hardcoded)
*(Covers FR55)*

**Given** a new directory is created in `/data/serverdata/`
**When** I refresh the file browser
**Then** the new directory appears in the listing

---

## Epic 10: Advanced Mod Browser

Admins can discover and install mods through a full-featured browser with search, filters, and sorting - matching the experience of mods.vintagestory.at directly within the management UI.

**FRs covered:** FR56, FR57, FR58, FR59, FR60, FR61, FR62, FR63, FR64, FR65, FR66, FR67, FR68, FR69, FR70, FR71, FR72, FR73, FR74, FR75, FR76, FR77, FR78, FR79, FR80, FR81, FR82, FR83, FR84, FR85

**MVP Scope:**

- Split Mods view into Installed/Browse tabs
- Smart landing page with newest mods, pre-filtered to game version
- Keyword search with debounce
- Filters: side, tags, game version, mod type
- Sorting: recent, downloads, trending, name
- Card display with thumbnails and compatibility badges
- Mod detail view with install/update actions
- Pagination for large result sets
- Direct install from browse results

---

### Story 10.1: Mod Browse API

As a **frontend developer**,
I want **an API endpoint that searches and filters the mod database**,
So that **the browse UI can display mods with all filtering and sorting options**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods/browse`
**When** no parameters are provided
**Then** I receive the newest mods, pre-filtered to the current game server version
**And** the response includes pagination metadata (total, page, page_size)
*(Covers FR59, FR60, FR61)*

**Given** I call `GET /api/v1alpha1/mods/browse?q=magic`
**When** the search parameter is provided
**Then** results are filtered to mods matching "magic" in name or description
*(Covers FR62)*

**Given** I call with filter parameters
**When** I include `side=server`, `tags=qol,utility`, `version=1.21`, `type=code`
**Then** results are filtered by all specified criteria (AND logic)
*(Covers FR65, FR66, FR67, FR68, FR69)*

**Given** I call with sort parameter
**When** I include `sort=downloads` (or `trending`, `recent`, `name`)
**Then** results are sorted accordingly
*(Covers FR71, FR72, FR73)*

**Given** I call with pagination parameters
**When** I include `page=2&page_size=20`
**Then** I receive the second page of 20 results
**And** response includes `total_count` for pagination UI
*(Covers FR80)*

**Given** the VintageStory mod API is unavailable
**When** I attempt to browse mods
**Then** I receive cached data if available, or a clear error message
*(Covers NFR11)*

---

### Story 10.2: Mods Tab Restructure

As an **administrator**,
I want **the Mods page split into Installed and Browse tabs**,
So that **I can manage installed mods separately from discovering new ones**.

**Acceptance Criteria:**

**Given** I navigate to the Mods page
**When** the page loads
**Then** I see two tabs: "Installed" and "Browse"
**And** "Installed" is the default active tab
*(Covers FR56)*

**Given** I click the "Installed" tab
**When** the tab activates
**Then** I see the existing mod management UI (list, enable, disable, remove, update)
*(Covers FR57)*

**Given** I click the "Browse" tab
**When** the tab activates
**Then** I see the new mod discovery interface
*(Covers FR58)*

**Given** I am on either tab
**When** I switch tabs
**Then** the URL updates to reflect the active tab (e.g., `/mods/installed`, `/mods/browse`)
**And** browser back/forward navigation works correctly

---

### Story 10.3: Browse Landing Page & Search

As an **administrator**,
I want **the Browse tab to show newest mods immediately with search capability**,
So that **I can discover mods without having to search first**.

**Acceptance Criteria:**

**Given** I navigate to the Browse tab
**When** the page loads
**Then** newest mods are displayed immediately (no user action required)
**And** results are pre-filtered to my game server version
*(Covers FR59, FR60, FR61)*

**Given** I see the Browse interface
**When** I look at the top of the page
**Then** I see a search input field

**Given** I type in the search field
**When** I stop typing (300ms debounce)
**Then** search results update automatically
*(Covers FR62, FR63)*

**Given** I have filters or sort applied
**When** I perform a search
**Then** the search respects existing filter and sort selections
*(Covers FR64)*

**Given** the search field has text
**When** I click a clear button or press Escape
**Then** the search is cleared and results return to default (newest)

---

### Story 10.4: Filter & Sort Controls

As an **administrator**,
I want **to filter and sort mod results**,
So that **I can find specific types of mods quickly**.

**Acceptance Criteria:**

**Given** I am on the Browse tab
**When** I view the filter controls
**Then** I see filter options for: Side, Tags, Game Version, Mod Type

**Given** I select a Side filter
**When** I choose "Server-only"
**Then** results update to show only server-side mods
*(Covers FR65)*

**Given** I select Tags
**When** I choose multiple tags (e.g., "QoL", "Utility")
**Then** results show mods matching ANY selected tag
*(Covers FR66)*

**Given** I select a Game Version filter
**When** I choose a specific version
**Then** results show mods compatible with that version
*(Covers FR67)*

**Given** I select a Mod Type filter
**When** I choose "Code Mod"
**Then** results show only code mods
*(Covers FR68)*

**Given** I have multiple filters active
**When** results are displayed
**Then** all filters are applied together (AND logic)
*(Covers FR69)*

**Given** filters are active
**When** I view the filter area
**Then** active filters are displayed as chips/badges that can be individually removed
*(Covers FR70)*

**Given** I view the sort dropdown
**When** I select a sort option (Newest, Downloads, Updated, Trending, Name)
**Then** results are re-sorted accordingly
*(Covers FR71)*

**Given** I haven't changed the sort
**When** browsing mods
**Then** the default sort is "Newest"
*(Covers FR72)*

**Given** I change the sort option
**When** I navigate within the browse experience
**Then** my sort selection persists
*(Covers FR73)*

---

### Story 10.5: Mod Card Display

As an **administrator**,
I want **mods displayed as informative cards**,
So that **I can quickly scan and evaluate mods**.

**Acceptance Criteria:**

**Given** browse results are displayed
**When** I view the mod grid/list
**Then** each mod shows: thumbnail image (or placeholder), name, author, download count, short description
*(Covers FR74)*

**Given** a mod card is displayed
**When** I view the compatibility indicator
**Then** I see a badge showing compatibility with my game server version (Compatible/Not verified/Incompatible)
*(Covers FR75)*

**Given** I see a mod card
**When** I click anywhere on the card
**Then** I navigate to the mod detail view
*(Covers FR76)*

**Given** mods have no thumbnail
**When** the card is rendered
**Then** a placeholder image is displayed

---

### Story 10.6: Mod Detail View

As an **administrator**,
I want **a detailed view of any mod**,
So that **I can read full information before installing**.

**Acceptance Criteria:**

**Given** I click a mod card
**When** the detail view opens
**Then** I see: full description (rendered markdown), all releases, dependencies, compatibility information
*(Covers FR77)*

**Given** I am viewing mod details
**When** I look at the install section
**Then** I see an "Install" button with a version dropdown to select which release
*(Covers FR78)*

**Given** the mod is already installed
**When** I view the detail page
**Then** I see "Installed: v1.2.3" indicator
**And** if an update is available, I see an "Update to v1.3.0" button
*(Covers FR79)*

**Given** I am on the detail view
**When** I click the back button or breadcrumb
**Then** I return to the browse results at the same position

---

### Story 10.7: Pagination

As an **administrator**,
I want **pagination for large result sets**,
So that **I can browse through thousands of mods efficiently**.

**Acceptance Criteria:**

**Given** browse results exceed one page
**When** results are displayed
**Then** pagination controls are visible (page numbers or "Load more" button)
*(Covers FR80)*

**Given** the UI implements infinite scroll
**When** I scroll to the bottom of the results
**Then** the next page of results loads automatically
*(Covers FR81 - Option A)*

**Given** the UI implements page controls
**When** I click page 2
**Then** page 2 results are displayed
*(Covers FR81 - Option B)*

**Given** I am on page 3 of results
**When** I click a mod card, view details, then go back
**Then** I return to page 3 at approximately the same scroll position
*(Covers FR82)*

---

### Story 10.8: Browse Install Integration

As an **administrator**,
I want **to install mods directly from the browser**,
So that **discovery and installation is a seamless experience**.

**Acceptance Criteria:**

**Given** I am viewing a mod card or detail view
**When** I click "Install"
**Then** an install confirmation dialog appears
*(Covers FR83)*

**Given** the install dialog is open
**When** I view the dialog
**Then** I see the compatibility check result (Compatible/Not verified/Incompatible)
**And** a warning is shown if not verified or incompatible
*(Covers FR84)*

**Given** I confirm installation
**When** the install completes successfully
**Then** a success toast appears
**And** the mod card/detail updates to show "Installed"
**And** the mod appears in the Installed tab
*(Covers FR85)*

**Given** I install a mod from the browse view
**When** I switch to the Installed tab
**Then** the newly installed mod is visible in the list

**Given** installation fails
**When** the error occurs
**Then** a clear error message is displayed
**And** the install button returns to its original state

---

## Epic 11: GameServer Navigation Refactor

Admins can navigate game server functionality through an organized sub-navigation structure, with dedicated pages for version management, settings, mods, and console access.

**Goal:** Split the current combined GameServer page into distinct sections with proper sub-navigation, improving organization and discoverability. Move Mods under Game Server as a logical grouping.

### Current State

- Single `/game-server` route with split-view layout (Console + Settings)
- Server installation lives on Dashboard (ServerInstallCard)
- Mods is a top-level navigation item
- No sub-navigation under Game Server

### Target State

```
Sidebar Navigation:
├── Dashboard (server stats at-a-glance)
├── Game Server (expandable)
│   ├── Installation / Version (dynamic label based on install state)
│   ├── Settings (game configuration)
│   ├── Mods (mod management + browser)
│   └── Console (full-page console view)
└── VSManager (app settings - formerly "Settings")
```

**Dynamic Label:** "Installation" when no server installed → "Version" once installed

**Rationale:**
- Mods are part of the game server, not a separate top-level concept
- Clear distinction: "Game Server → Settings" = game config vs "VSManager" = application settings
- Logical flow: Version → Settings → Mods → Console

---

### Story 11.1: Sub-Navigation Infrastructure

As a **frontend developer**,
I want **an expandable sub-navigation component in the sidebar**,
So that **Game Server can have nested navigation items**.

**Acceptance Criteria:**

**Given** I view the sidebar
**When** I click on "Game Server"
**Then** the section expands to show sub-items: Version/Installation, Settings, Mods, Console
**And** the expanded/collapsed state is persisted in localStorage

**Given** the Game Server section is expanded
**When** I click on "Game Server" again
**Then** the section collapses to hide sub-items

**Given** I am on a Game Server sub-page (e.g., `/game-server/console`)
**When** I view the sidebar
**Then** the Game Server section is automatically expanded
**And** the active sub-item is highlighted

**Given** no server is installed
**When** I view the sidebar
**Then** the first sub-item shows "Installation"

**Given** a server is installed
**When** I view the sidebar
**Then** the first sub-item shows "Version"

**Given** the sidebar is in collapsed mode (icons only)
**When** I hover over the Game Server icon
**Then** a tooltip/flyout shows the sub-navigation items

**Tasks:**
- [ ] Create ExpandableNavItem component with expand/collapse behavior
- [ ] Add sub-navigation items to Sidebar.tsx
- [ ] Update routes in App.tsx for nested routing
- [ ] Implement localStorage persistence for expanded state
- [ ] Add dynamic label logic based on server install state
- [ ] Handle collapsed sidebar hover behavior
- [ ] Update tests for new navigation structure

---

### Story 11.2: Version/Installation Page

As an **administrator**,
I want **a dedicated page for server version management**,
So that **I can see and manage which server version is installed**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I navigate to `/game-server/version`
**Then** I see the installation interface (version input + install button)
**And** the page title is "Server Installation"

**Given** a server is installed
**When** I navigate to `/game-server/version`
**Then** I see the current installed version prominently displayed
**And** I see server state (running/stopped)
**And** the page title is "Server Version"

**Given** server installation is in progress
**When** I view the page
**Then** I see installation progress (stage + percentage)
**And** the install button is disabled

**Given** a newer version is available
**When** I view the page (server installed)
**Then** I see an "Update Available" indicator
**And** I can see the new version number

**Given** I am on the version page
**When** the page loads
**Then** the ServerInstallCard logic from Dashboard is reused/moved here

**Tasks:**
- [ ] Create `/features/game-server/VersionPage.tsx`
- [ ] Move ServerInstallCard logic from Dashboard
- [ ] Add installed version display with status
- [ ] Add update available indicator
- [ ] Add route `/game-server/version`
- [ ] Add tests for version page states

---

### Story 11.3: Settings Page Extraction

As an **administrator**,
I want **a dedicated full-page view for game server settings**,
So that **I have more space to view and edit configuration**.

**Acceptance Criteria:**

**Given** I navigate to `/game-server/settings`
**When** the page loads
**Then** I see the GameConfigPanel in a full-width layout
**And** server status is shown in the page header

**Given** no server is installed
**When** I navigate to `/game-server/settings`
**Then** I see a message indicating server must be installed first
**And** a link to the Installation page is provided

**Given** I am on the settings page
**When** I edit a setting
**Then** the existing auto-save behavior works as before
**And** toast notifications appear for success/error

**Given** the settings page is displayed
**When** I view the layout
**Then** setting groups have better horizontal space utilization than the previous split-view

**Tasks:**
- [ ] Create `/features/game-server/SettingsPage.tsx`
- [ ] Extract GameConfigPanel into full-page layout
- [ ] Add server status header component
- [ ] Add empty state for no server installed
- [ ] Add route `/game-server/settings`
- [ ] Improve layout for wider screens
- [ ] Add tests for settings page

---

### Story 11.4: Mods Page Migration

As an **administrator**,
I want **Mods accessible under Game Server navigation**,
So that **mod management is logically grouped with other server functions**.

**Acceptance Criteria:**

**Given** I navigate to `/game-server/mods`
**When** the page loads
**Then** I see the existing Mods interface (Installed/Browse tabs)
**And** all existing mod functionality works as before

**Given** I navigate to the old `/mods` URL
**When** the page loads
**Then** I am redirected to `/game-server/mods`

**Given** I am on the mod detail page
**When** I view the URL
**Then** it is `/game-server/mods/browse/:slug`

**Given** no server is installed
**When** I navigate to `/game-server/mods`
**Then** I see a message indicating server must be installed first
**And** compatibility checking is disabled (no game version to check against)

**Tasks:**
- [ ] Move mods feature routes under `/game-server/mods`
- [ ] Update all internal links to mods pages
- [ ] Add redirect from old `/mods` routes
- [ ] Update breadcrumbs in mod detail page
- [ ] Add empty state for no server installed
- [ ] Update tests for new routes

---

### Story 11.5: Console Page Extraction

As an **administrator**,
I want **a dedicated full-page console view**,
So that **I have maximum space for monitoring server output**.

**Acceptance Criteria:**

**Given** I navigate to `/game-server/console`
**When** the page loads
**Then** I see the ConsolePanel in a full-width, full-height layout
**And** server status is shown in the page header

**Given** no server is installed
**When** I navigate to `/game-server/console`
**Then** I see a message indicating server must be installed first
**And** the console is not displayed

**Given** the server is stopped
**When** I view the console page
**Then** I can still view console history
**And** command input is disabled with explanation

**Given** I am on the console page
**When** I select a different log source (dropdown)
**Then** the log streaming switches as before

**Tasks:**
- [ ] Create `/features/game-server/ConsolePage.tsx`
- [ ] Extract ConsolePanel into full-page layout
- [ ] Add server status header component
- [ ] Add empty state for no server installed
- [ ] Add route `/game-server/console`
- [ ] Maximize vertical space usage
- [ ] Add tests for console page

---

### Story 11.6: Dashboard & Navigation Cleanup

As an **administrator**,
I want **a simplified Dashboard focused on status**,
So that **it serves as a quick overview without duplicate functionality**.

**Acceptance Criteria:**

**Given** I navigate to Dashboard
**When** the page loads
**Then** ServerInstallCard is NOT displayed (moved to Version page)
**And** Server status card remains with basic info

**Given** no server is installed
**When** I view the Dashboard
**Then** I see a card indicating "No server installed"
**And** a button/link takes me to `/game-server/version`

**Given** the sidebar navigation is updated
**When** I view the sidebar
**Then** "Settings" is renamed to "VSManager"
**And** "Mods" is no longer a top-level item

**Given** the default route for `/game-server`
**When** I navigate to `/game-server` without a sub-path
**Then** I am redirected to `/game-server/version`

**Tasks:**
- [ ] Remove ServerInstallCard from Dashboard
- [ ] Add "No server installed" card with link to version page
- [ ] Rename "Settings" to "VSManager" in sidebar
- [ ] Remove top-level "Mods" from sidebar
- [ ] Set default redirect for `/game-server` → `/game-server/version`
- [ ] Update any remaining internal navigation links
- [ ] Add tests for navigation changes

---

## Epic 12: Enhanced Dashboard with Server Metrics

Admins can monitor server health and performance through a comprehensive dashboard with real-time metrics, historical charts, and quick actions.

**Goal:** Transform Dashboard from a basic status card into a monitoring hub with CPU, memory, player count, and time-series visualizations.

### Current State

- Dashboard shows: server state badge, version, uptime, disk space, controls
- No historical data, no player info, no resource metrics
- Single polling interval (5 seconds)
- Basic status card layout

### Target State

- Real-time metrics: Memory (API + Game), CPU, player count
- Time-series charts for key metrics (1h, 6h, 24h views)
- Server health indicators with thresholds
- Quick links to other sections
- Responsive card-based layout

---

### Story 12.1: Epic 12 Technical Preparation

As a **developer**,
I want **to research metrics collection and visualization approaches**,
So that **subsequent stories have a solid technical foundation**.

**Acceptance Criteria:**

**Given** we need to collect process metrics
**When** I research approaches
**Then** I document how to use psutil for API server metrics
**And** I document how to find and monitor the VintageStory game server process

**Given** we need to display charts
**When** I evaluate charting libraries
**Then** I recommend a library (recharts, visx, or lightweight alternative)
**And** I document bundle size and feature trade-offs

**Given** we need to store historical metrics
**When** I design the storage approach
**Then** I document in-memory ring buffer design with configurable retention
**And** I specify data structure for metrics snapshots

**Given** we may want player information
**When** I research VintageStory server capabilities
**Then** I document how to get player count (console parsing, RCON, or API)
**And** I note any limitations

**Tasks:**
- [ ] Research psutil for process metrics collection
- [ ] Document game server process discovery (by name or PID file)
- [ ] Evaluate charting libraries (recharts vs alternatives)
- [ ] Design MetricsSnapshot data model
- [ ] Design in-memory ring buffer with retention policy
- [ ] Research player count extraction methods
- [ ] Update architecture.md with findings

---

### Story 12.2: Metrics Collection Service

As a **backend developer**,
I want **a service that collects server metrics periodically**,
So that **current and historical metrics are available via API**.

**Acceptance Criteria:**

**Given** the API server is running
**When** the metrics collection job executes (default every 10 seconds)
**Then** it collects: timestamp, api_memory_mb, api_cpu_percent

**Given** the game server process is running
**When** metrics are collected
**Then** it also collects: game_memory_mb, game_cpu_percent

**Given** the game server is not running
**When** metrics are collected
**Then** game_memory_mb and game_cpu_percent are null
**And** collection continues without error

**Given** metrics are collected
**When** the ring buffer is at capacity (default 1 hour at 10s intervals = 360 samples)
**Then** the oldest samples are evicted (FIFO)

**Given** the collection interval is configurable
**When** `VS_METRICS_INTERVAL` is set
**Then** metrics are collected at the specified interval

**Tasks:**
- [ ] Add psutil dependency to pyproject.toml
- [ ] Create MetricsService with collect() method
- [ ] Create MetricsSnapshot Pydantic model
- [ ] Implement ring buffer storage with configurable size
- [ ] Implement game server process discovery
- [ ] Register metrics collection background job
- [ ] Add tests for metrics collection

---

### Story 12.3: Metrics API Endpoints

As a **frontend developer**,
I want **API endpoints to retrieve current and historical metrics**,
So that **the dashboard can display real-time and chart data**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/metrics/current` as Admin
**When** metrics have been collected
**Then** I receive the latest MetricsSnapshot
**And** response includes: timestamp, api_memory_mb, api_cpu_percent, game_memory_mb, game_cpu_percent

**Given** I call `GET /api/v1alpha1/metrics/history` as Admin
**When** I don't specify parameters
**Then** I receive all available historical metrics (up to buffer size)

**Given** I call `GET /api/v1alpha1/metrics/history?minutes=60`
**When** I specify a time range
**Then** I receive metrics from the last 60 minutes only

**Given** I am authenticated as Monitor
**When** I call metrics endpoints
**Then** I receive a 403 Forbidden (metrics are Admin-only)

**Given** no metrics have been collected yet
**When** I call metrics endpoints
**Then** I receive an empty response (not an error)

**Tasks:**
- [ ] Create /metrics router with current and history endpoints
- [ ] Add time range filtering for history
- [ ] Add Admin-only authorization
- [ ] Add OpenAPI documentation
- [ ] Add tests for metrics API

---

### Story 12.4: Dashboard Stats Cards

As an **administrator**,
I want **stat cards showing current server metrics**,
So that **I can see server health at a glance**.

**Acceptance Criteria:**

**Given** I view the Dashboard
**When** the page loads
**Then** I see stat cards for: Server Status, Memory Usage, Disk Space, Uptime

**Given** the Memory Usage card is displayed
**When** metrics are available
**Then** I see API memory and Game memory separately
**And** values update in real-time (polling every 10 seconds)

**Given** the Server Status card is displayed
**When** I view it
**Then** I see status badge (running/stopped/etc.)
**And** Start/Stop/Restart buttons are available

**Given** the game server is not running
**When** I view the Memory card
**Then** Game memory shows "N/A" or "-"
**And** API memory is still displayed

**Given** I am on a mobile device
**When** I view the Dashboard
**Then** stat cards stack vertically in a responsive layout

**Tasks:**
- [ ] Create StatCard component with icon, label, value, trend
- [ ] Create useMetrics hook for polling current metrics
- [ ] Redesign Dashboard layout with card grid
- [ ] Implement Memory card with API/Game breakdown
- [ ] Implement Disk Space card (existing data)
- [ ] Implement Uptime card
- [ ] Move server controls to Status card
- [ ] Add responsive layout for mobile
- [ ] Add tests for stat cards

---

### Story 12.5: Dashboard Time-Series Charts

As an **administrator**,
I want **charts showing metrics over time**,
So that **I can identify trends and anomalies**.

**Acceptance Criteria:**

**Given** I view the Dashboard
**When** the page loads
**Then** I see a Memory Usage chart showing API and Game memory over time

**Given** the chart is displayed
**When** I view it
**Then** it shows data for the selected time range (default 1 hour)
**And** API and Game memory are shown as separate lines

**Given** I want to change the time range
**When** I click a time range selector (15m, 1h, 6h, 24h)
**Then** the chart updates to show that time period

**Given** the game server was stopped during the time range
**When** I view the chart
**Then** Game memory line has gaps where data is unavailable

**Given** I hover over a point on the chart
**When** the tooltip appears
**Then** I see the timestamp and exact values

**Tasks:**
- [ ] Add recharts (or chosen library) dependency
- [ ] Create MetricsChart component
- [ ] Create useMetricsHistory hook
- [ ] Implement time range selector
- [ ] Style chart with Catppuccin theme colors
- [ ] Add responsive sizing
- [ ] Add tests for chart component

---

## Epic 13: Server Version Browser

Admins can browse and install server versions through a visual interface similar to the mod browser, replacing the simple version input with a discoverable list of available releases.

**Goal:** Replace free-text version input with a browsable list showing available versions, release info, and one-click install/upgrade.

### Current State

- User must know exact version number (e.g., "1.21.3")
- Version input is free-text field
- No visibility into available versions or release dates
- No upgrade path visibility
- Must type version manually

### Target State

- Browse available versions with release metadata
- Filter by channel (stable/unstable)
- One-click install or upgrade
- Version comparison and warnings
- Similar UX to mod browser

---

### Story 13.0: Epic 13 Technical Preparation

As a **developer**,
I want **to research VintageStory version APIs and plan the browser implementation**,
So that **subsequent stories have accurate API documentation and design**.

**Acceptance Criteria:**

**Given** we need to fetch available versions
**When** I research the VintageStory version API
**Then** I document the response format from stable.json and unstable.json
**And** I note all available fields (version, filename, filesize, md5, etc.)

**Given** we want to show release information
**When** I research available metadata
**Then** I document what release info is available (date, changelog, etc.)
**And** I note any limitations

**Given** we need to cache version data
**When** I design the caching strategy
**Then** I document cache TTL (versions don't change frequently)
**And** I specify how to handle cache refresh

**Given** we want a similar UX to mod browser
**When** I design the UI approach
**Then** I document which patterns can be reused from Epic 10

**Tasks:**
- [ ] Document VintageStory version API response format
- [ ] Identify all available version metadata
- [ ] Design versions caching strategy (extend existing VersionsCache)
- [ ] Plan UI component reuse from mod browser
- [ ] Update architecture.md with findings

---

### Story 13.1: Server Versions API

As a **frontend developer**,
I want **an API endpoint to list available server versions**,
So that **the version browser can display all available releases**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/versions` as Admin
**When** the endpoint is called
**Then** I receive a list of available versions from both stable and unstable channels
**And** each version includes: version, channel, filename, filesize, md5, is_latest

**Given** I call `GET /api/v1alpha1/versions?channel=stable`
**When** the channel filter is applied
**Then** I receive only stable versions

**Given** I call `GET /api/v1alpha1/versions?channel=unstable`
**When** the channel filter is applied
**Then** I receive only unstable versions

**Given** the VintageStory API is unavailable
**When** I call the versions endpoint
**Then** I receive cached data if available
**And** the response includes a `cached: true` indicator

**Given** I call `GET /api/v1alpha1/versions/{version}`
**When** the version exists
**Then** I receive detailed information for that specific version

**Tasks:**
- [ ] Extend VersionsCache to store full version lists (not just latest)
- [ ] Create /versions router with list and detail endpoints
- [ ] Add channel filtering
- [ ] Add cache indicator in response
- [ ] Add background job to refresh version cache
- [ ] Add tests for versions API

---

### Story 13.2: Version Card Component

As an **administrator**,
I want **versions displayed as informative cards**,
So that **I can quickly scan and compare available versions**.

**Acceptance Criteria:**

**Given** the version list is displayed
**When** I view the version cards
**Then** each card shows: version number, channel badge (stable/unstable), file size

**Given** a version is the currently installed version
**When** I view its card
**Then** I see an "Installed" badge

**Given** a version is the latest in its channel
**When** I view its card
**Then** I see a "Latest" badge

**Given** I click on a version card
**When** the click is registered
**Then** the version detail view opens (or inline expansion)

**Tasks:**
- [ ] Create VersionCard component
- [ ] Add channel badge (stable = green, unstable = yellow)
- [ ] Add "Installed" badge logic
- [ ] Add "Latest" badge logic
- [ ] Style consistently with mod cards
- [ ] Add tests for version card

---

### Story 13.3: Version List Page

As an **administrator**,
I want **a browsable list of server versions**,
So that **I can see all available versions and choose one to install**.

**Acceptance Criteria:**

**Given** I navigate to `/game-server/version`
**When** a server is installed
**Then** I see my current version prominently at the top
**And** below I see "Available Versions" with the version list

**Given** I view the version list
**When** it loads
**Then** versions are grouped or filterable by channel (All, Stable, Unstable)
**And** default filter is "All"

**Given** I select the "Stable" filter
**When** the filter is applied
**Then** only stable versions are displayed

**Given** versions are displayed
**When** I view the list
**Then** versions are sorted by version number (newest first)

**Given** I am viewing on mobile
**When** the page loads
**Then** the layout is responsive and cards stack appropriately

**Tasks:**
- [ ] Create VersionListPage component (or update existing VersionPage)
- [ ] Add channel filter tabs/buttons
- [ ] Create useVersions hook for data fetching
- [ ] Display current version section
- [ ] Add responsive layout
- [ ] Add loading and error states
- [ ] Add tests for version list

---

### Story 13.4: Install/Upgrade Flow

As an **administrator**,
I want **a confirmation dialog when installing or upgrading versions**,
So that **I understand the implications before making changes**.

**Acceptance Criteria:**

**Given** I click "Install" on a version (no server installed)
**When** the dialog opens
**Then** I see version details and an "Install" confirmation button

**Given** I click "Upgrade" on a version (server installed, newer version)
**When** the dialog opens
**Then** I see current version → new version comparison
**And** I see a warning that the server will be stopped

**Given** I click "Downgrade" on a version (server installed, older version)
**When** the dialog opens
**Then** I see a prominent warning about downgrading
**And** I must confirm I understand the risks

**Given** the server is currently running
**When** I confirm install/upgrade
**Then** I see a warning that the server will be stopped
**And** the server is stopped before installation begins

**Given** I confirm installation
**When** the installation starts
**Then** I see progress indication (stage + percentage)
**And** I can stay on the page or navigate away

**Given** installation completes successfully
**When** the process finishes
**Then** I see a success message
**And** the version list updates to show the new installed version

**Tasks:**
- [ ] Create InstallVersionDialog component
- [ ] Add version comparison display
- [ ] Add downgrade warning
- [ ] Add server-running warning
- [ ] Integrate with existing install progress tracking
- [ ] Add success/error handling
- [ ] Add tests for install flow

---

### Story 13.5: Version Page Integration

As an **administrator**,
I want **the version browser integrated into the Version page**,
So that **version management is a cohesive experience**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I view `/game-server/version`
**Then** I see the version browser with "Install" buttons
**And** page title is "Server Installation"

**Given** a server is installed
**When** I view `/game-server/version`
**Then** I see current version info at the top
**And** I see "Change Version" section with the browser below
**And** page title is "Server Version"

**Given** an update is available
**When** I view the version page
**Then** the newer version card is highlighted
**And** an "Update Available" banner is shown

**Given** I want to quickly install the latest stable
**When** I view the page
**Then** there is a prominent "Install Latest Stable" button (if not installed)
**Or** "Update to Latest" button (if installed and update available)

**Tasks:**
- [ ] Integrate version browser into VersionPage
- [ ] Add "Install Latest Stable" quick action
- [ ] Add "Update Available" banner
- [ ] Highlight newer versions
- [ ] Add page title dynamic switching
- [ ] Add tests for integrated page

---

### Story 13.6: Server Uninstall API

As a **developer**,
I want **an API endpoint to uninstall the server**,
So that **I can programmatically remove the server installation**.

**Background:** Added from Epic 11 retrospective to support testing workflow. Allows clean uninstall for version switching without manual file deletion.

**Acceptance Criteria:**

**Given** the server is running
**When** I call `DELETE /api/v1alpha1/server` as Admin
**Then** the server is stopped first
**And** the `/data/server` directory is deleted
**And** the server state becomes `not_installed`
**And** I receive a success response

**Given** the server is stopped
**When** I call `DELETE /api/v1alpha1/server` as Admin
**Then** the `/data/server` directory is deleted
**And** the server state becomes `not_installed`
**And** I receive a success response

**Given** no server is installed
**When** I call `DELETE /api/v1alpha1/server` as Admin
**Then** I receive a 404 or appropriate error response
**And** no files are deleted

**Given** I call the uninstall endpoint
**When** the operation completes
**Then** the `/data/serverdata` directory is preserved (configs, mods, worlds)

**Tasks:**
- [ ] Add `DELETE /api/v1alpha1/server` endpoint to server router
- [ ] Implement uninstall logic in ServerService (stop if running, delete /data/server)
- [ ] Add state transition to `not_installed` after successful uninstall
- [ ] Preserve `/data/serverdata` directory (configs, mods, worlds)
- [ ] Add error handling for edge cases (already not_installed, deletion failures)
- [ ] Add comprehensive tests for uninstall scenarios

---

### Story 13.7: Server Uninstall UI

As an **administrator**,
I want **a way to uninstall the server from the UI**,
So that **I can cleanly remove the installation without manual file deletion**.

**Background:** Added from Epic 11 retrospective to support testing workflow. Provides UI for the uninstall API with appropriate confirmation.

**Acceptance Criteria:**

**Given** a server is installed
**When** I view the Version page
**Then** I see a "Remove Server" button (or similar)
**And** the button is styled as a destructive action (red/warning)

**Given** the server is running
**When** I click "Remove Server"
**Then** I see a confirmation dialog explaining the server will be stopped
**And** the dialog notes that configuration and world data will be preserved

**Given** the server is stopped
**When** I click "Remove Server"
**Then** I see a confirmation dialog
**And** the dialog notes that configuration and world data will be preserved

**Given** I confirm the uninstall
**When** the operation completes
**Then** I see a success toast notification
**And** the page transitions to the "Server Installation" view
**And** the sidebar label changes from "Version" to "Installation"

**Given** I cancel the confirmation dialog
**When** I close the dialog
**Then** no action is taken
**And** the server remains installed

**Tasks:**
- [ ] Add "Remove Server" button to VersionPage (visible when installed)
- [ ] Create UninstallConfirmDialog component with appropriate warnings
- [ ] Implement useUninstallServer mutation hook
- [ ] Handle loading state during uninstall operation
- [ ] Add success toast and state transition after uninstall
- [ ] Disable button when server is in transitional states (starting, stopping, installing)
- [ ] Add tests for uninstall UI flow
