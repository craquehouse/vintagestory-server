---
stepsCompleted: [1, 2, 3, 4]
inputDocuments:
  - '_bmad-output/planning-artifacts/prd.md'
  - '_bmad-output/planning-artifacts/architecture.md'
  - '_bmad-output/planning-artifacts/ux-design-specification.md'
---

# vintagestory-server - Epic Breakdown

## Overview

This document provides the complete epic and story breakdown for vintagestory-server, decomposing the requirements from the PRD, UX Design, and Architecture requirements into implementable stories.

## Requirements Inventory

### Functional Requirements

**Server Lifecycle Management (FR1-5):**

- FR1: Admin can view current server status (running/stopped, uptime, game version)
- FR2: Admin can start the game server
- FR3: Admin can stop the game server gracefully
- FR4: Admin can restart the game server
- FR5: Monitor can view current server status (running/stopped, uptime, game version)

**Console Access (FR6-9):**

- FR6: Admin can view real-time game server console output via WebSocket stream
- FR7: Admin can scroll back through console history buffer
- FR8: Admin can send commands to the game server console
- FR9: Console access is restricted to Admin role only (sensitive data)

**Mod Management (FR10-17):**

- FR10: Admin can view list of installed mods with version and compatibility status
- FR11: Admin can install a mod by entering its slug
- FR12: System validates mod compatibility against current game version before installation
- FR13: System displays warning when mod is not explicitly compatible with current game version
- FR14: Admin can enable an installed mod
- FR15: Admin can disable an installed mod
- FR16: Admin can remove an installed mod
- FR17: Monitor can view list of installed mods (read-only)

**Game Configuration (FR18-22):**

- FR18: Admin can view list of game configuration files
- FR19: Admin can read contents of a game configuration file
- FR20: Admin can edit and save game configuration files
- FR21: Monitor can view list of game configuration files (read-only)
- FR22: Monitor can read contents of game configuration files (read-only)

**Settings Management (FR23-26):**

- FR23: Admin can view server management settings (server name, whitelist mode, etc.)
- FR24: Admin can update server management settings
- FR25: Admin can view player whitelist
- FR26: Admin can add/remove players from whitelist

**Health & Observability (FR27-30):**

- FR27: System exposes health check endpoint (`/healthz`) without authentication
- FR28: System exposes readiness check endpoint (`/readyz`) without authentication
- FR29: Health endpoints report game server process status (running/stopped)
- FR30: System exposes metrics endpoint (`/metrics`) without authentication (POST-MVP)

**Authentication & Authorization (FR31-37):**

- FR31: Protected API endpoints require valid API key via `X-API-Key` header
- FR32: System supports Monitor API keys with read-only access to non-sensitive data
- FR33: System supports Admin API keys with full access including console and write operations
- FR34: Console stream and history are restricted to Admin role (sensitive data protection)
- FR35: Write operations are restricted to Admin role
- FR36: System returns 401 Unauthorized for missing or invalid API key
- FR37: System returns 403 Forbidden when key lacks permission for requested operation

**Deployment & Setup (FR38-39):**

- FR38: System can be deployed via docker-compose with minimal configuration
- FR39: System configuration is provided via environment variables

### NonFunctional Requirements

**Performance (NFR1-3):**

- NFR1: Console output appears in web UI within 1 second of being generated by game server
- NFR2: WebSocket preferred for real-time streaming; polling at 1-second intervals is acceptable fallback
- NFR3: API endpoints under local control respond within 500ms; external API calls may take longer with progress indication

**Security (NFR4-7):**

- NFR4: API keys are stored securely and never logged in plaintext
- NFR5: TLS termination is out of scope for MVP; users requiring HTTPS must provide a reverse proxy
- NFR6: Console history buffer does not persist to disk (sensitive data protection)
- NFR7: Failed authentication attempts are logged for security monitoring

**Reliability (NFR8-10):**

- NFR8: Management API remains available when game server is stopped or crashed
- NFR9: System recovers gracefully from game server process crashes without requiring restart
- NFR10: WebSocket disconnections reconnect automatically without losing significant console history

**Integration (NFR11-13):**

- NFR11: System gracefully handles VintageStory mod API unavailability (cached data, clear error messages)
- NFR12: Mod installation failures due to network issues are reported clearly to user
- NFR13: System does not require external network access for core functionality (mod management requires it)

**Observability (NFR14-16):**

- NFR14: API server logs are structured (JSON) for easy parsing; game server logs remain in their native format
- NFR15: Health endpoints differentiate between "API healthy" and "game server healthy"
- NFR16: Errors include sufficient context for debugging without exposing sensitive data

### Additional Requirements

**From Architecture - Starter Template:**

- Project uses mise for development environment (Python 3.13, uv, Bun)
- Backend: uv + FastAPI pattern with httpx, pydantic-settings, structlog
- Frontend: Vite + React 19.2 + TypeScript + shadcn/ui + Tailwind CSS v4
- Project initialization should be the first implementation story

**From Architecture - Infrastructure:**

- Single container deployment (API + game server in same container) for simplified deployment
- Base image: `mcr.microsoft.com/dotnet/runtime:8.0.22-noble-amd64` (Ubuntu Noble + .NET 8 + Python 3.12)
- Single volume mount at `/data` for all persistence
- Atomic file writes for state persistence (temp file + rename pattern)
- Docker registry: `ghcr.io/craquehouse/vintagestory-server`

**From Architecture - State Management:**

- In-memory state with JSON file sync (`data/state/state.json`)
- WebSocket reconnection with exponential backoff (max 30s, 10 retries)

**From Architecture - API Patterns:**

- API versioning: `/api/v1alpha1`
- Response envelope: `{"status": "ok|error", "data": {...}}`
- JSON field naming: snake_case in API, camelCase in frontend (transform at boundary)
- Error codes centralized in `models/errors.py`

**From Architecture - Frontend Patterns:**

- TanStack Query v5 for server state
- React Context for UI state only (theme, sidebar)
- React Router v7 for navigation
- xterm.js for terminal (Console + Shell modes)
- Catppuccin Mocha/Latte theming via JSON config files

**From UX Design - Server Lifecycle:**

- Server can be in "Not Installed" state with Install button and version input
- Installation progress stages: Downloading → Extracting → Verifying → Complete
- Version mismatch alert when installed differs from configured
- Server states: Not Installed, Installing, Installed (Stopped), Installed (Running), Upgrading, Error

**From UX Design - Pending Restart Pattern:**

- Changes requiring restart tracked server-side (`pendingRestart` state)
- Persistent header banner: "⟳ Restart required · N pending changes · [Restart Now]"
- Two workflows: immediate restart or batch changes

**From UX Design - Components:**

- ServerStatusBadge (6 states with icons)
- CompatibilityBadge (Compatible/Not verified/Incompatible)
- ModLookupInput (accepts slugs or URLs, debounced lookup)
- PendingRestartBanner (header component)
- TerminalView (xterm.js wrapper with Console/Shell tabs)
- ServerInstallCard (empty state for no server)
- InstallProgress (progress bar with stage labels)

**From UX Design - Accessibility:**

- WCAG 2.1 Level AA compliance
- Minimum 44x44px touch targets
- Keyboard navigation via Radix primitives
- ARIA live regions for dynamic content
- Respect `prefers-reduced-motion`

### FR Coverage Map

| FR | Epic | Description |
|----|------|-------------|
| FR1 | Epic 3 | Admin views server status |
| FR2 | Epic 3 | Admin starts server |
| FR3 | Epic 3 | Admin stops server |
| FR4 | Epic 3 | Admin restarts server |
| FR5 | Epic 3 | Monitor views server status |
| FR6 | Epic 4 | Admin views console stream |
| FR7 | Epic 4 | Admin scrolls console history |
| FR8 | Epic 4 | Admin sends console commands |
| FR9 | Epic 4 | Console restricted to Admin |
| FR10 | Epic 5 | Admin views mod list |
| FR11 | Epic 5 | Admin installs mod by slug |
| FR12 | Epic 5 | System validates compatibility |
| FR13 | Epic 5 | System shows compatibility warnings |
| FR14 | Epic 5 | Admin enables mod |
| FR15 | Epic 5 | Admin disables mod |
| FR16 | Epic 5 | Admin removes mod |
| FR17 | Epic 5 | Monitor views mod list |
| FR18 | Epic 6 | Admin views config file list |
| FR19 | Epic 6 | Admin reads config file |
| FR20 | Epic 6 | Admin edits config file |
| FR21 | Epic 6 | Monitor views config file list |
| FR22 | Epic 6 | Monitor reads config file |
| FR23 | Epic 7 | Admin views settings |
| FR24 | Epic 7 | Admin updates settings |
| FR25 | Epic 7 | Admin views whitelist |
| FR26 | Epic 7 | Admin manages whitelist |
| FR27 | Epic 1 | Health endpoint exposed |
| FR28 | Epic 1 | Readiness endpoint exposed |
| FR29 | Epic 1 | Health reports game server status |
| FR31 | Epic 2 | API key authentication |
| FR32 | Epic 2 | Monitor role support |
| FR33 | Epic 2 | Admin role support |
| FR34 | Epic 2 | Console restricted to Admin |
| FR35 | Epic 2 | Writes restricted to Admin |
| FR36 | Epic 2 | 401 for invalid key |
| FR37 | Epic 2 | 403 for insufficient role |
| FR38 | Epic 1 | docker-compose deployment |
| FR39 | Epic 1 | Environment variable config |

**Note:** FR30 (Metrics endpoint) is marked POST-MVP in PRD, not included in MVP epics.

## Epic List

### Epic 1: Project Foundation & Health Monitoring

Developers can set up the project using the defined starter template, and operations teams can verify the system is running via health endpoints. This epic establishes the scaffolding for all future development and provides the first deployable artifact.

**FRs covered:** FR27, FR28, FR29, FR38, FR39

**MVP Scope:**

- Project initialization per Architecture starter template (mise, uv, Bun)
- Backend scaffolding (FastAPI + dependencies)
- Frontend scaffolding (Vite + React + shadcn/ui)
- Health endpoints (`/healthz`, `/readyz`) without authentication
- docker-compose configuration
- Environment variable configuration pattern

---

### Epic 2: Authentication & API Security

API consumers can authenticate with appropriate role-based access, and the system enforces security boundaries between Admin and Monitor roles.

**FRs covered:** FR31, FR32, FR33, FR34, FR35, FR36, FR37

**MVP Scope:**

- API key authentication via `X-API-Key` header
- Admin role with full access
- Monitor role with read-only access to non-sensitive data
- Console access restricted to Admin only
- Proper 401/403 responses
- Security logging for failed auth attempts

---

### Epic 3: Server Lifecycle Management

Admins can install the VintageStory server by version number and control it (start, stop, restart) from the web UI. This is the first "real user value" epic.

**FRs covered:** FR1, FR2, FR3, FR4, FR5

**MVP Scope:**

- Server installation by version number (download tarball, extract, post-install setup)
- Download progress indication
- Server start/stop/restart controls
- Server status display (running/stopped, version, uptime)
- Dashboard with server controls
- ServerStatusBadge component
- ServerInstallCard for empty state

**Post-MVP (deferred):**

- Version switching/upgrade
- Rollback to previous version

---

### Epic 4: Real-Time Console Access

Admins can monitor game server output in real-time and send commands, enabling troubleshooting without container access.

**FRs covered:** FR6, FR7, FR8, FR9

**MVP Scope:**

- WebSocket console streaming
- Console history buffer (in-memory ring buffer)
- Command input to game server
- Admin-only access enforcement
- TerminalView component with xterm.js (Console mode)
- Auto-reconnection with exponential backoff

**Post-MVP (deferred):**

- Shell tab (PTY access)
- Console search

---

### Epic 5: Mod Management

Admins can install, enable/disable, and remove mods via the web UI with automatic compatibility validation. This is the "slug to success" experience - the defining user journey.

**FRs covered:** FR10, FR11, FR12, FR13, FR14, FR15, FR16, FR17

**MVP Scope:**

- Mod list with version and compatibility status
- Install mod by slug (or URL - parsed to slug)
- Compatibility validation against game version
- Compatibility warnings for unverified mods
- Enable/disable mods
- Remove mods
- Monitor read-only access to mod list
- ModLookupInput component
- CompatibilityBadge component
- Pending restart indication

**Post-MVP (deferred):**

- Mod update detection
- One-click updates
- Version switching/rollback

---

### Epic 6: Game Configuration Management

Admins can view and edit game server configuration files through the web UI, completing the "no terminal needed" promise.

**FRs covered:** FR18, FR19, FR20, FR21, FR22

**MVP Scope:**

- List game configuration files
- Read configuration file contents
- Edit and save configuration files (JSON)
- Monitor read-only access
- Config editor component
- Pending restart pattern for config changes

---

### Epic 7: Server Settings & Whitelist Management

Admins can manage server-level settings and control player access via whitelist.

**FRs covered:** FR23, FR24, FR25, FR26

**MVP Scope:**

- View server management settings
- Update settings (server name, whitelist mode, etc.)
- View player whitelist
- Add/remove players from whitelist
- Settings UI page

---

## Epic Summary

| Epic | Title | FRs | User Value |
|------|-------|-----|------------|
| 1 | Project Foundation & Health Monitoring | 5 | Deployable system with health checks |
| 2 | Authentication & API Security | 7 | Secure role-based API access |
| 3 | Server Lifecycle Management | 5 | Install and control game server |
| 4 | Real-Time Console Access | 4 | Monitor and command server in browser |
| 5 | Mod Management | 8 | Install mods by slug with compatibility |
| 6 | Game Configuration Management | 5 | Edit configs without file access |
| 7 | Server Settings & Whitelist | 4 | Manage settings and player access |
| **Total** | | **38** | |

## Dependency Flow

```
Epic 1 (Foundation)
    ↓
Epic 2 (Auth) ←── Required by all protected endpoints
    ↓
Epic 3 (Server Lifecycle) ←── First user value
    ↓
Epic 4 (Console) ←── Requires server to monitor
    ↓
Epic 5 (Mods) ←── Uses console for verification, server for restarts
    ↓
Epic 6 (Config) ←── Uses pending restart pattern
    ↓
Epic 7 (Settings) ←── Final admin capabilities
```

Each epic is standalone once complete and enables future epics without requiring them.

---

## Epic 1: Project Foundation & Health Monitoring

Developers can set up the project using the defined starter template, and operations teams can verify the system is running via health endpoints.

### Story 1.1: Initialize Development Environment and Project Structure

As a **developer**,
I want **a properly configured development environment with project scaffolding**,
So that **I can begin implementing features with consistent tooling across the team**.

**Acceptance Criteria:**

**Given** a fresh clone of the repository
**When** I run `mise trust && mise install`
**Then** Python 3.13, uv, and Bun are installed at the pinned versions
**And** a `.mise.toml` file exists at the project root with tool versions specified

**Given** the development environment is set up
**When** I navigate to the `api/` directory
**Then** a `pyproject.toml` exists with project name `vintagestory-api`
**And** dependencies include `fastapi[standard]`, `httpx`, `pydantic-settings`, `structlog`
**And** dev dependencies include `pytest`, `pytest-asyncio`, `ruff`, `respx`

**Given** the development environment is set up
**When** I navigate to the `web/` directory
**Then** a `package.json` exists with React 19.2 and TypeScript configured
**And** Tailwind CSS v4 is installed and configured
**And** shadcn/ui is initialized with the project's component configuration

**Given** the project structure is initialized
**When** I examine the repository root
**Then** the directory structure matches the Architecture specification
**And** `.gitignore` excludes appropriate files (node_modules, .venv, **pycache**, data/)

---

### Story 1.2: Backend API Skeleton with Health Endpoints

As an **operations engineer**,
I want **health check endpoints that report system status**,
So that **I can configure Kubernetes probes and monitoring systems**.

**Acceptance Criteria:**

**Given** the API server is running
**When** I send a GET request to `/healthz`
**Then** I receive a 200 status code
**And** the response follows the envelope format `{"status": "ok", "data": {...}}`
**And** no authentication is required
*(Covers FR27)*

**Given** the API server is running
**When** I send a GET request to `/readyz`
**Then** I receive a 200 status code when the API is ready to serve requests
**And** the response includes readiness information
**And** no authentication is required
*(Covers FR28)*

**Given** the API server is running
**When** I query the health endpoints
**Then** the response includes game server process status (running/stopped/not_installed)
**And** the API health is reported separately from game server health
*(Covers FR29, NFR15)*

**Given** the API server is running
**When** the game server process is not running
**Then** the API still responds to health checks (API healthy, game stopped)
*(Covers NFR8)*

**Given** any API request is made
**When** the server processes the request
**Then** structured JSON logs are emitted (in production mode)
**And** human-readable logs are emitted (in development mode)
*(Covers NFR14)*

---

### Story 1.3: Frontend Application Shell

As an **administrator**,
I want **a web interface with navigation and theming**,
So that **I can access server management features through a consistent UI**.

**Acceptance Criteria:**

**Given** I navigate to the web application
**When** the page loads
**Then** I see a sidebar with navigation items (Dashboard, Mods, Config, Terminal)
**And** I see a header displaying the server name placeholder
**And** the application uses Catppuccin Mocha theme by default (dark mode)

**Given** I am viewing the application
**When** I click the theme toggle in the header
**Then** the theme switches between Mocha (dark) and Latte (light)
**And** my preference is persisted in localStorage

**Given** I am viewing the application
**When** my system has `prefers-color-scheme: dark` or `light`
**Then** the initial theme respects my system preference (if no stored preference)

**Given** I am on any page
**When** I click a navigation item in the sidebar
**Then** the URL updates to reflect the selected section
**And** the main content area displays the corresponding view
**And** the active navigation item is visually highlighted

**Given** I am viewing the sidebar
**When** I click the collapse button
**Then** the sidebar collapses to icon-only mode (64px)
**And** my collapse preference is persisted in localStorage

**Given** I resize my browser to mobile width (<768px)
**When** the viewport is narrow
**Then** the sidebar is hidden by default
**And** a hamburger menu button appears to toggle the sidebar overlay

---

### Story 1.4: Docker Deployment Configuration

As a **server administrator**,
I want **to deploy the application using docker-compose**,
So that **I can run VintageStory Server Manager with minimal configuration**.

**Acceptance Criteria:**

**Given** I have Docker and docker-compose installed
**When** I run `docker compose up -d` with `docker-compose.yaml`
**Then** the container starts successfully
**And** the web UI is accessible on port 8080
**And** the health endpoints respond correctly
*(Covers FR38)*

**Given** the container is running
**When** I check the container logs
**Then** I see structured startup messages
**And** no errors are present for a clean start

**Given** I set environment variables (`VS_API_KEY_ADMIN`, etc.)
**When** the container starts
**Then** the application reads configuration from environment variables
**And** default values are used for optional unset variables
*(Covers FR39)*

**Given** a `docker-compose.dev.yaml` file exists
**When** I run `docker compose -f docker-compose.dev.yaml up --build`
**Then** the image builds from local source
**And** development defaults are applied (e.g., `VS_DEBUG=true`)

**Given** the container is running
**When** I examine the volume mounts
**Then** `/data` is mounted for persistent storage
**And** the directory structure matches Architecture specification (`/data/server/`, `/data/mods/`, `/data/state/`, etc.)

**Given** I have a `.env.example` file
**When** I review it
**Then** all configurable environment variables are documented with descriptions

---

## Epic 2: Authentication & API Security

API consumers can authenticate with appropriate role-based access, and the system enforces security boundaries between Admin and Monitor roles.

### Story 2.1: API Key Authentication Middleware

As an **API consumer**,
I want **to authenticate using an API key in the request header**,
So that **I can access protected endpoints securely**.

**Acceptance Criteria:**

**Given** I have a valid Admin API key
**When** I send a request with `X-API-Key: <valid-admin-key>` header
**Then** the request is authenticated successfully
**And** my role is identified as Admin
*(Covers FR31, FR33)*

**Given** I have a valid Monitor API key
**When** I send a request with `X-API-Key: <valid-monitor-key>` header
**Then** the request is authenticated successfully
**And** my role is identified as Monitor
*(Covers FR31, FR32)*

**Given** I send a request without an API key
**When** the endpoint requires authentication
**Then** I receive a 401 Unauthorized response
**And** the response body contains `{"status": "error", "error": {"code": "UNAUTHORIZED", "message": "..."}}`
*(Covers FR36)*

**Given** I send a request with an invalid API key
**When** the endpoint requires authentication
**Then** I receive a 401 Unauthorized response
**And** the failed attempt is logged with request context (but not the key value)
*(Covers FR36, NFR7)*

**Given** any authentication attempt occurs
**When** the system processes the request
**Then** API keys are never logged in plaintext
*(Covers NFR4)*

**Given** health endpoints (`/healthz`, `/readyz`)
**When** I send a request without authentication
**Then** the request succeeds (health endpoints remain unauthenticated)

---

### Story 2.2: Role-Based Access Control for API Endpoints

As a **system administrator**,
I want **different API keys to have different permission levels**,
So that **I can grant read-only access to monitoring systems while reserving write access for admins**.

**Acceptance Criteria:**

**Given** I am authenticated as Admin
**When** I attempt any API operation (read or write)
**Then** the operation is permitted
*(Covers FR33)*

**Given** I am authenticated as Monitor
**When** I attempt a read operation on non-sensitive endpoints
**Then** the operation is permitted
*(Covers FR32)*

**Given** I am authenticated as Monitor
**When** I attempt a write operation (POST, PUT, DELETE on protected resources)
**Then** I receive a 403 Forbidden response
**And** the response body contains `{"status": "error", "error": {"code": "FORBIDDEN", "message": "..."}}`
*(Covers FR35, FR37)*

**Given** I am authenticated as Monitor
**When** I attempt to access console endpoints (stream or history)
**Then** I receive a 403 Forbidden response
**And** the error message indicates console access requires Admin role
*(Covers FR34)*

**Given** role permissions are checked
**When** a 403 response is returned
**Then** the response clearly indicates the required role for the operation

---

### Story 2.3: Frontend API Client with Authentication

As a **frontend developer**,
I want **an API client that handles authentication and key transformation**,
So that **all API calls are properly authenticated and response data is correctly formatted**.

**Acceptance Criteria:**

**Given** the frontend application is configured
**When** API calls are made
**Then** the `X-API-Key` header is automatically included from configuration

**Given** the API returns a response with snake_case fields
**When** the API client processes the response
**Then** fields are transformed to camelCase for frontend consumption

**Given** the API returns a 401 Unauthorized response
**When** the frontend receives the error
**Then** an appropriate error state is displayed to the user
**And** the user is informed that authentication failed

**Given** the API returns a 403 Forbidden response
**When** the frontend receives the error
**Then** an appropriate error state is displayed
**And** the user is informed they lack permission for the operation

**Given** TanStack Query is configured
**When** API calls are made
**Then** server state is managed through TanStack Query hooks
**And** client-only state (theme, sidebar) uses React Context

---

## Epic 3: Server Lifecycle Management

Admins can install the VintageStory server by version number and control it (start, stop, restart) from the web UI.

### Story 3.1: Server Installation Service

As an **administrator**,
I want **to install the VintageStory server by providing a version number**,
So that **I can get a game server running without manual file management**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I call `POST /api/v1alpha1/server/install` with `{"version": "1.21.3"}`
**Then** the system downloads the server tarball from the VintageStory CDN
**And** extracts it to `/data/server/`
**And** creates a symlink from `/data/server/Mods` to `/data/mods/`
**And** copies default config if none exists

**Given** a server installation is in progress
**When** I query `GET /api/v1alpha1/server/install/status`
**Then** I receive progress information (stage: downloading/extracting/configuring, percentage if available)

**Given** the download fails (network error, invalid version)
**When** the installation process encounters the error
**Then** the error is reported clearly with actionable message
**And** the system returns to "not installed" state

**Given** the version format is invalid
**When** I attempt installation
**Then** I receive a 400 Bad Request with validation error details

**Given** a server is already installed
**When** I attempt to install again
**Then** I receive an error indicating server already exists (version switching is post-MVP)

---

### Story 3.2: Server Lifecycle Control API

As an **administrator**,
I want **to start, stop, and restart the game server via API**,
So that **I can control the server without container access**.

**Acceptance Criteria:**

**Given** a server is installed and stopped
**When** I call `POST /api/v1alpha1/server/start`
**Then** the game server process starts
**And** the response confirms the action was initiated
*(Covers FR2)*

**Given** a server is running
**When** I call `POST /api/v1alpha1/server/stop`
**Then** the game server receives a graceful shutdown signal
**And** the process terminates cleanly
**And** the response confirms the action was initiated
*(Covers FR3)*

**Given** a server is running
**When** I call `POST /api/v1alpha1/server/restart`
**Then** the server stops gracefully and starts again
**And** the response confirms the restart was initiated
*(Covers FR4)*

**Given** no server is installed
**When** I attempt to start/stop/restart
**Then** I receive a 400 Bad Request indicating no server is installed

**Given** the server process crashes unexpectedly
**When** the API detects the crash
**Then** the server status updates to "stopped" with exit code information
**And** the API remains available and responsive
*(Covers NFR8, NFR9)*

---

### Story 3.3: Server Status API

As an **administrator or monitor**,
I want **to view the current server status**,
So that **I can see if the server is running and its version**.

**Acceptance Criteria:**

**Given** the API is running
**When** I call `GET /api/v1alpha1/server/status` as Admin
**Then** I receive server status including: state (not_installed/stopped/starting/running/stopping), version, uptime (if running)
*(Covers FR1)*

**Given** the API is running
**When** I call `GET /api/v1alpha1/server/status` as Monitor
**Then** I receive the same status information (read-only access permitted)
*(Covers FR5)*

**Given** the server is running
**When** I query status
**Then** uptime is calculated from process start time
**And** version is read from the installed server

**Given** the server is not installed
**When** I query status
**Then** state is "not_installed"
**And** version and uptime are null

---

### Story 3.4: Dashboard with Server Controls UI

As an **administrator**,
I want **a dashboard showing server status with control buttons**,
So that **I can monitor and control the server from the web interface**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I view the Dashboard
**Then** I see the ServerInstallCard with version input and "Install Server" button
**And** server control buttons (Start/Stop/Restart) are not visible

**Given** a server installation is in progress
**When** I view the Dashboard
**Then** I see a progress indicator with current stage and percentage
**And** the install button is disabled

**Given** a server is installed and stopped
**When** I view the Dashboard
**Then** I see the ServerStatusBadge showing "Stopped" (red)
**And** server version is displayed
**And** "Start" button is enabled
**And** "Stop" and "Restart" buttons are disabled

**Given** a server is running
**When** I view the Dashboard
**Then** I see the ServerStatusBadge showing "Running" (green)
**And** server version and uptime are displayed
**And** "Stop" and "Restart" buttons are enabled
**And** "Start" button is disabled

**Given** I click a server control button
**When** the action is in progress
**Then** the button shows a loading state
**And** a toast notification appears on success or failure

**Given** the server state changes
**When** the Dashboard is open
**Then** the status updates automatically without page refresh (TanStack Query polling or refetch)

---

## Epic 4: Real-Time Console Access

Admins can monitor game server output in real-time and send commands, enabling troubleshooting without container access.

### Story 4.1: Console Buffer Service

As a **backend developer**,
I want **an in-memory ring buffer that captures game server output**,
So that **console history is available for streaming and retrieval**.

**Acceptance Criteria:**

**Given** the game server is running
**When** it produces stdout/stderr output
**Then** the output is captured and stored in the ring buffer
**And** timestamps are added to each line

**Given** the ring buffer has a configured size (default 10,000 lines)
**When** new output exceeds the buffer capacity
**Then** the oldest lines are discarded (FIFO)

**Given** the console buffer contains data
**When** the API server restarts
**Then** the buffer is empty (in-memory only, no disk persistence)
*(Covers NFR6)*

**Given** the game server crashes or stops
**When** the admin queries console history
**Then** the buffer contents up to the crash are preserved
**And** available for troubleshooting

---

### Story 4.2: WebSocket Console Streaming

As an **administrator**,
I want **to receive real-time console output via WebSocket**,
So that **I can monitor server activity as it happens**.

**Acceptance Criteria:**

**Given** I am authenticated as Admin
**When** I connect to `ws://host/api/v1alpha1/console` with `?api_key=<admin-key>`
**Then** the WebSocket connection is established
**And** I begin receiving console output in real-time
*(Covers FR6)*

**Given** I am connected to the console WebSocket
**When** the game server produces output
**Then** I receive the output within 1 second
*(Covers NFR1)*

**Given** I connect to the console WebSocket
**When** the connection is established
**Then** I receive the recent buffer history (configurable, e.g., last 100 lines)
*(Covers FR7)*

**Given** I am authenticated as Monitor
**When** I attempt to connect to the console WebSocket
**Then** the connection is rejected with 403 Forbidden
*(Covers FR9)*

**Given** I have no API key or an invalid key
**When** I attempt to connect to the console WebSocket
**Then** the connection is rejected with 401 Unauthorized

**Given** the WebSocket connection is lost
**When** the client reconnects
**Then** recent buffer history is sent to fill the gap

---

### Story 4.3: Console Command Input

As an **administrator**,
I want **to send commands to the game server through the console**,
So that **I can interact with the server without container access**.

**Acceptance Criteria:**

**Given** I am connected to the console WebSocket as Admin
**When** I send a message with type "command" and content "/help"
**Then** the command is written to the game server's stdin
**And** the command response appears in the console stream
*(Covers FR8)*

**Given** I send a command
**When** the server processes it
**Then** my sent command is echoed back (or marked) in the stream for confirmation

**Given** the game server is not running
**When** I attempt to send a command
**Then** I receive an error message indicating the server is stopped

**Given** I am authenticated as Monitor
**When** I attempt to send a command via any mechanism
**Then** the request is rejected with 403 Forbidden
*(Covers FR9)*

---

### Story 4.4: Terminal View Component

As an **administrator**,
I want **a terminal interface in the web UI showing console output**,
So that **I can view and interact with the server console visually**.

**Acceptance Criteria:**

**Given** I navigate to the Terminal page as Admin
**When** the page loads
**Then** I see an xterm.js terminal component
**And** it connects to the console WebSocket automatically
**And** displays incoming console output with Catppuccin theming

**Given** the terminal is connected
**When** new console output arrives
**Then** it appears in the terminal view immediately
**And** the terminal auto-scrolls to show new content

**Given** I am viewing the terminal
**When** I scroll up in the terminal
**Then** I can view console history from the buffer
*(Covers FR7)*

**Given** I type in the terminal and press Enter
**When** the command is submitted
**Then** it is sent via the WebSocket command mechanism
**And** I see the command and its response in the terminal
*(Covers FR8)*

**Given** the WebSocket connection is lost
**When** the terminal detects disconnection
**Then** a "Disconnected" indicator is shown
**And** the terminal attempts to reconnect with exponential backoff (max 30s, 10 retries)
*(Covers NFR10)*

**Given** reconnection succeeds
**When** the terminal reconnects
**Then** recent history is loaded to fill the gap
**And** the "Disconnected" indicator is removed

**Given** I am authenticated as Monitor
**When** I navigate to the Terminal page
**Then** I see a message indicating console access requires Admin role
**And** no terminal is displayed

---

## Epic 5: Mod Management

Admins can install, enable/disable, and remove mods via the web UI with automatic compatibility validation.

### Story 5.0: Epic 5 Technical Preparation

As a **development team**,
I want **to complete technical preparation for Epic 5 (Mod Management)**,
So that **we have updated architecture docs, caching patterns, and refactored tests before implementing mod features**.

**Background:** This preparatory story was defined during the Epic 4 retrospective. Epic 5 introduces external API dependencies and new UI patterns that benefit from upfront research and infrastructure improvements.

**Acceptance Criteria:**

**Given** the architecture documentation is reviewed
**When** I read the architecture.md file
**Then** it reflects current implementation state and any needed updates for Epic 5

**Given** a manual test checklist exists
**When** I review `docs/manual-test-checklist.md`
**Then** it contains smoke tests for Epics 1-4 functionality and placeholders for Epic 5

**Given** the mod API patterns are verified
**When** I review `agentdocs/modstoryapi.md`
**Then** it contains current API patterns with working examples verified against the live API

**Given** pending restart pattern research is complete
**When** I review the research findings
**Then** it documents the UI pattern for tracking changes requiring server restart

**Given** caching strategy research is complete
**When** I review the caching documentation
**Then** it covers artifact caching (server tarballs) and API response caching (mod data, TTL-based)

**Given** large test files are refactored
**When** I examine `api/tests/`
**Then** `test_console.py` and `test_server.py` are split into focused modules

**Tasks:**

- [ ] Task 1: Architecture doc review and update
- [ ] Task 2: Manual test checklist creation (`docs/manual-test-checklist.md`)
- [ ] Task 3: Mod API integration patterns verification
- [ ] Task 4: Pending restart pattern research
- [ ] Task 5: Caching strategy research (artifacts + API responses)
- [ ] Task 6: Refactor large test files into focused modules

---

### Story 5.1: Mod Service and State Management

As a **backend developer**,
I want **a service that tracks installed mods and their state**,
So that **mod information is persisted and available to the API**.

**Acceptance Criteria:**

**Given** mods are installed in `/data/mods/`
**When** the API starts or rescans
**Then** the mod service discovers all `.zip` files in the mods directory
**And** extracts mod metadata (modid, version, name) from `modinfo.json`

**Given** a mod's enabled/disabled state changes
**When** the state is updated
**Then** the change is persisted to `/data/state/state.json` (atomic write)
**And** a pending restart flag is set if the server is running

**Given** state persistence fails
**When** an atomic write is attempted
**Then** the temp file is written first, then renamed (prevents corruption)

---

### Story 5.2: Mod Installation API

As an **administrator**,
I want **to install a mod by entering its slug**,
So that **I don't need to manually download and copy mod files**.

**Acceptance Criteria:**

**Given** I call `POST /api/v1alpha1/mods` with `{"slug": "smithingplus"}`
**When** the mod exists on mods.vintagestory.at
**Then** the latest release is downloaded to `/data/mods/`
**And** the mod appears in the installed mods list
*(Covers FR11)*

**Given** I provide a full URL instead of a slug
**When** I call the install endpoint with `{"slug": "https://mods.vintagestory.at/smithingplus"}`
**Then** the slug is extracted from the URL and installation proceeds

**Given** the mod slug does not exist
**When** I attempt installation
**Then** I receive a 404 error with message "Mod not found"

**Given** the VintageStory mod API is unavailable
**When** I attempt installation
**Then** I receive a 502 error with clear message about external API failure
*(Covers NFR11)*

**Given** the download fails mid-transfer
**When** the error occurs
**Then** partial files are cleaned up
**And** a clear error message is returned
*(Covers NFR12)*

---

### Story 5.3: Mod Compatibility Validation

As an **administrator**,
I want **to see mod compatibility before installation**,
So that **I can make informed decisions about installing mods**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods/lookup/{slug}`
**When** the mod exists
**Then** I receive mod details including: name, description, latest version, and compatibility status

**Given** the installed game server version is 1.21.3
**When** I look up a mod with release tagged for "1.21.3"
**Then** compatibility status is "compatible"
*(Covers FR12)*

**Given** the installed game server version is 1.21.3
**When** I look up a mod with latest release tagged for "1.21.0"
**Then** compatibility status is "not_verified"
**And** a warning message indicates the mod wasn't explicitly tested for this version
*(Covers FR13)*

**Given** the installed game server version is 1.21.3
**When** I look up a mod with release tagged for "1.20.x" only
**Then** compatibility status is "incompatible"
**And** a warning message indicates version mismatch

**Given** I install a mod with "not_verified" or "incompatible" status
**When** the installation completes
**Then** the mod is installed (user made informed choice)
**And** the compatibility status is stored with the mod record

---

### Story 5.4: Mod Enable/Disable and Remove API

As an **administrator**,
I want **to enable, disable, and remove installed mods**,
So that **I can manage which mods are active without deleting files**.

**Acceptance Criteria:**

**Given** a mod is installed and enabled
**When** I call `POST /api/v1alpha1/mods/{slug}/disable`
**Then** the mod is marked as disabled in state
**And** the mod file is moved/renamed to indicate disabled status (e.g., `.disabled` suffix)
**And** a pending restart flag is set
*(Covers FR15)*

**Given** a mod is installed and disabled
**When** I call `POST /api/v1alpha1/mods/{slug}/enable`
**Then** the mod is marked as enabled in state
**And** the mod file is restored to active status
**And** a pending restart flag is set
*(Covers FR14)*

**Given** a mod is installed
**When** I call `DELETE /api/v1alpha1/mods/{slug}`
**Then** the mod file is deleted from `/data/mods/`
**And** the mod is removed from state
**And** a pending restart flag is set
*(Covers FR16)*

**Given** the mod slug doesn't exist in installed mods
**When** I attempt enable/disable/remove
**Then** I receive a 404 error

---

### Story 5.5: Mod List API

As an **administrator or monitor**,
I want **to view a list of installed mods with their status**,
So that **I can see what mods are installed and their compatibility**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods` as Admin
**When** mods are installed
**Then** I receive a list of installed mods with: slug, name, version, enabled status, compatibility status
*(Covers FR10)*

**Given** I call `GET /api/v1alpha1/mods` as Monitor
**When** mods are installed
**Then** I receive the same list (read-only access permitted)
*(Covers FR17)*

**Given** no mods are installed
**When** I query the mod list
**Then** I receive an empty array

**Given** the pending restart flag is set
**When** I query the mod list
**Then** the response includes `pending_restart: true` indicator

---

### Story 5.6: Mod Management UI

As an **administrator**,
I want **a web interface for managing mods**,
So that **I can install, view, and manage mods visually**.

**Acceptance Criteria:**

**Given** I navigate to the Mods page
**When** the page loads
**Then** I see a ModLookupInput field with placeholder "Enter mod slug or paste URL"
**And** I see a table of installed mods (or empty state if none)

**Given** I type a mod slug in the input
**When** I stop typing (300ms debounce)
**Then** a lookup request is made
**And** mod details appear in a preview card below the input

**Given** the mod lookup returns results
**When** I view the preview card
**Then** I see mod name, description, and CompatibilityBadge (green/yellow/red)
**And** an "Install" button is available

**Given** I click "Install" on a compatible mod
**When** installation completes
**Then** a success toast appears
**And** the mod appears in the installed mods table
**And** the pending restart banner appears in the header

**Given** I click "Install" on an incompatible mod
**When** I click the button
**Then** a warning dialog appears asking for confirmation
**And** I can choose to proceed or cancel

**Given** the mods table is displayed
**When** I view an installed mod row
**Then** I see: mod name, installed version, compatibility badge, enabled/disabled toggle, remove button

**Given** I toggle a mod's enabled state
**When** the toggle is clicked
**Then** the state updates optimistically
**And** a toast confirms success or shows error
**And** pending restart indicator updates

**Given** I click the remove button on a mod
**When** the confirmation dialog appears and I confirm
**Then** the mod is removed from the list
**And** a success toast appears

---

## Epic 6: Game Configuration Management

Admins can view and edit game server configuration files through the web UI.

### Story 6.1: Configuration Files API

As an **administrator or monitor**,
I want **to list and read game configuration files**,
So that **I can view server settings without file system access**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/config/files` as Admin or Monitor
**When** config files exist in `/data/config/`
**Then** I receive a list of configuration file names (e.g., `serverconfig.json`, `servermagicnumbers.json`)
*(Covers FR18, FR21)*

**Given** I call `GET /api/v1alpha1/config/files/{filename}` as Admin or Monitor
**When** the file exists
**Then** I receive the file contents as JSON
*(Covers FR19, FR22)*

**Given** I request a file that doesn't exist
**When** the API processes the request
**Then** I receive a 404 error

**Given** I request a file outside the config directory (path traversal attempt)
**When** the API validates the path
**Then** I receive a 400 error and the request is rejected

---

### Story 6.2: Configuration File Editing API

As an **administrator**,
I want **to edit and save game configuration files**,
So that **I can change server settings without file system access**.

**Acceptance Criteria:**

**Given** I call `PUT /api/v1alpha1/config/files/{filename}` as Admin with valid JSON body
**When** the file exists and JSON is valid
**Then** the file is saved using atomic write (temp + rename)
**And** a pending restart flag is set
*(Covers FR20)*

**Given** I submit invalid JSON
**When** the API validates the content
**Then** I receive a 400 error with JSON parsing error details

**Given** I am authenticated as Monitor
**When** I attempt to PUT a config file
**Then** I receive a 403 Forbidden

**Given** I save a config file
**When** the save succeeds
**Then** the response includes `pending_restart: true` indicator

---

### Story 6.3: Configuration Editor UI

As an **administrator**,
I want **a web interface for viewing and editing configuration files**,
So that **I can manage server settings visually**.

**Acceptance Criteria:**

**Given** I navigate to the Config page as Admin
**When** the page loads
**Then** I see a list/tabs of available configuration files

**Given** I select a configuration file
**When** the file loads
**Then** I see a JSON editor with syntax highlighting
**And** the current file contents are displayed

**Given** I am viewing a config file as Monitor
**When** the file loads
**Then** I see the contents in read-only mode
**And** the save button is hidden or disabled

**Given** I make changes to a config file as Admin
**When** I click "Save"
**Then** the file is saved via the API
**And** a success toast appears
**And** the pending restart banner updates

**Given** I make changes and attempt to navigate away
**When** unsaved changes exist
**Then** a warning dialog asks for confirmation

**Given** I submit invalid JSON
**When** validation fails
**Then** an inline error message appears
**And** the save button is disabled until JSON is valid

---

## Epic 7: Server Settings & Whitelist Management

Admins can manage server-level settings and control player access via whitelist.

### Story 7.1: Server Settings API

As an **administrator**,
I want **to view and update server management settings**,
So that **I can configure the management application**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/settings` as Admin
**When** settings exist
**Then** I receive current settings including: server_name, whitelist_enabled, and other management settings
*(Covers FR23)*

**Given** I call `PUT /api/v1alpha1/settings` as Admin with updated values
**When** the request is valid
**Then** the settings are saved using atomic write
**And** the response confirms the update
*(Covers FR24)*

**Given** I submit invalid setting values
**When** validation fails
**Then** I receive a 400 error with field-specific validation messages

**Given** I am authenticated as Monitor
**When** I attempt to update settings
**Then** I receive a 403 Forbidden

---

### Story 7.2: Whitelist Management API

As an **administrator**,
I want **to view and manage the player whitelist**,
So that **I can control who can join the server**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/settings/whitelist` as Admin
**When** the whitelist exists
**Then** I receive a list of whitelisted player names/UUIDs
*(Covers FR25)*

**Given** I call `POST /api/v1alpha1/settings/whitelist` with `{"player": "PlayerName"}`
**When** the player is not already whitelisted
**Then** the player is added to the whitelist
**And** the whitelist file is saved
*(Covers FR26)*

**Given** I call `DELETE /api/v1alpha1/settings/whitelist/{player}`
**When** the player is whitelisted
**Then** the player is removed from the whitelist
**And** the whitelist file is saved
*(Covers FR26)*

**Given** I attempt to add a player already on the whitelist
**When** the API processes the request
**Then** I receive a 409 Conflict or the request is idempotent (no error, already exists)

---

### Story 7.3: Settings and Whitelist UI

As an **administrator**,
I want **a web interface for managing settings and whitelist**,
So that **I can configure the server visually**.

**Acceptance Criteria:**

**Given** I navigate to a Settings page as Admin
**When** the page loads
**Then** I see current settings in a form layout
**And** I see the whitelist section with player list

**Given** I modify a setting
**When** I click "Save"
**Then** the settings are saved via the API
**And** a success toast appears

**Given** I view the whitelist section
**When** players are whitelisted
**Then** I see a list of player names with remove buttons

**Given** I type a player name in the "Add Player" input
**When** I click "Add" or press Enter
**Then** the player is added to the whitelist
**And** the list updates to show the new player

**Given** I click remove on a whitelisted player
**When** I confirm the action
**Then** the player is removed from the list
**And** a success toast appears

**Given** whitelist_enabled is a toggle setting
**When** I toggle it
**Then** the setting updates immediately
**And** the whitelist section visual state reflects enabled/disabled

---

## Story Summary

| Epic | Stories | Total |
|------|---------|-------|
| Epic 1: Project Foundation & Health Monitoring | 1.1, 1.2, 1.3, 1.4 | 4 |
| Epic 2: Authentication & API Security | 2.1, 2.2, 2.3 | 3 |
| Epic 3: Server Lifecycle Management | 3.1, 3.2, 3.3, 3.4, 3.5 | 5 |
| Epic 4: Real-Time Console Access | 4.0, 4.1, 4.2, 4.3, 4.4 | 5 |
| Epic 5: Mod Management | 5.0, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6 | 7 |
| Epic 6: Game Configuration Management | 6.1, 6.2, 6.3 | 3 |
| Epic 7: Server Settings & Whitelist Management | 7.1, 7.2, 7.3 | 3 |
| **Total** | | **30** |
