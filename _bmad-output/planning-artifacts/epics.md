---
stepsCompleted: [1, 2, 3, 4]
inputDocuments:
  - '_bmad-output/planning-artifacts/prd.md'
  - '_bmad-output/planning-artifacts/architecture.md'
  - '_bmad-output/planning-artifacts/ux-design-specification.md'
lastUpdated: '2026-01-03'
updates:
  - date: '2026-01-03'
    description: 'Added Epic 9 (7 stories) and Epic 10 (8 stories) for QoL Polish and Advanced Mod Browser'
---

# vintagestory-server - Epic Breakdown

## Overview

This document provides the complete epic and story breakdown for vintagestory-server, decomposing the requirements from the PRD, UX Design, and Architecture requirements into implementable stories.

## Requirements Inventory

### Functional Requirements

**Server Lifecycle Management (FR1-5):**

- FR1: Admin can view current server status (running/stopped, uptime, game version)
- FR2: Admin can start the game server
- FR3: Admin can stop the game server gracefully
- FR4: Admin can restart the game server
- FR5: Monitor can view current server status (running/stopped, uptime, game version)

**Console Access (FR6-9):**

- FR6: Admin can view real-time game server console output via WebSocket stream
- FR7: Admin can scroll back through console history buffer
- FR8: Admin can send commands to the game server console
- FR9: Console access is restricted to Admin role only (sensitive data)

**Mod Management (FR10-17):**

- FR10: Admin can view list of installed mods with version and compatibility status
- FR11: Admin can install a mod by entering its slug
- FR12: System validates mod compatibility against current game version before installation
- FR13: System displays warning when mod is not explicitly compatible with current game version
- FR14: Admin can enable an installed mod
- FR15: Admin can disable an installed mod
- FR16: Admin can remove an installed mod
- FR17: Monitor can view list of installed mods (read-only)

**Game Configuration (FR18-22):**

- FR18: Admin can view list of game configuration files
- FR19: Admin can read contents of a game configuration file
- FR20: Admin can edit and save game configuration files
- FR21: Monitor can view list of game configuration files (read-only)
- FR22: Monitor can read contents of game configuration files (read-only)

**Settings Management (FR23-26):**

- FR23: Admin can view server management settings (server name, whitelist mode, etc.)
- FR24: Admin can update server management settings
- FR25: Admin can view player whitelist
- FR26: Admin can add/remove players from whitelist

**Health & Observability (FR27-30):**

- FR27: System exposes health check endpoint (`/healthz`) without authentication
- FR28: System exposes readiness check endpoint (`/readyz`) without authentication
- FR29: Health endpoints report game server process status (running/stopped)
- FR30: System exposes metrics endpoint (`/metrics`) without authentication (POST-MVP)

**Authentication & Authorization (FR31-37):**

- FR31: Protected API endpoints require valid API key via `X-API-Key` header
- FR32: System supports Monitor API keys with read-only access to non-sensitive data
- FR33: System supports Admin API keys with full access including console and write operations
- FR34: Console stream and history are restricted to Admin role (sensitive data protection)
- FR35: Write operations are restricted to Admin role
- FR36: System returns 401 Unauthorized for missing or invalid API key
- FR37: System returns 403 Forbidden when key lacks permission for requested operation

**Deployment & Setup (FR38-39):**

- FR38: System can be deployed via docker-compose with minimal configuration
- FR39: System configuration is provided via environment variables

### NonFunctional Requirements

**Performance (NFR1-3):**

- NFR1: Console output appears in web UI within 1 second of being generated by game server
- NFR2: WebSocket preferred for real-time streaming; polling at 1-second intervals is acceptable fallback
- NFR3: API endpoints under local control respond within 500ms; external API calls may take longer with progress indication

**Security (NFR4-7):**

- NFR4: API keys are stored securely and never logged in plaintext
- NFR5: TLS termination is out of scope for MVP; users requiring HTTPS must provide a reverse proxy
- NFR6: Console history buffer does not persist to disk (sensitive data protection)
- NFR7: Failed authentication attempts are logged for security monitoring

**Reliability (NFR8-10):**

- NFR8: Management API remains available when game server is stopped or crashed
- NFR9: System recovers gracefully from game server process crashes without requiring restart
- NFR10: WebSocket disconnections reconnect automatically without losing significant console history

**Integration (NFR11-13):**

- NFR11: System gracefully handles VintageStory mod API unavailability (cached data, clear error messages)
- NFR12: Mod installation failures due to network issues are reported clearly to user
- NFR13: System does not require external network access for core functionality (mod management requires it)

**Observability (NFR14-16):**

- NFR14: API server logs are structured (JSON) for easy parsing; game server logs remain in their native format
- NFR15: Health endpoints differentiate between "API healthy" and "game server healthy"
- NFR16: Errors include sufficient context for debugging without exposing sensitive data

### Additional Requirements

**From Architecture - Starter Template:**

- Project uses mise for development environment (Python 3.13, uv, Bun)
- Backend: uv + FastAPI pattern with httpx, pydantic-settings, structlog
- Frontend: Vite + React 19.2 + TypeScript + shadcn/ui + Tailwind CSS v4
- Project initialization should be the first implementation story

**From Architecture - Infrastructure:**

- Single container deployment (API + game server in same container) for simplified deployment
- Base image: `mcr.microsoft.com/dotnet/runtime:8.0.22-noble-amd64` (Ubuntu Noble + .NET 8 + Python 3.12)
- Single volume mount at `/data` for all persistence
- Atomic file writes for state persistence (temp file + rename pattern)
- Docker registry: `ghcr.io/craquehouse/vintagestory-server`

**From Architecture - State Management:**

- In-memory state with JSON file sync (`data/state/state.json`)
- WebSocket reconnection with exponential backoff (max 30s, 10 retries)

**From Architecture - API Patterns:**

- API versioning: `/api/v1alpha1`
- Response envelope: `{"status": "ok|error", "data": {...}}`
- JSON field naming: snake_case in API, camelCase in frontend (transform at boundary)
- Error codes centralized in `models/errors.py`

**From Architecture - Frontend Patterns:**

- TanStack Query v5 for server state
- React Context for UI state only (theme, sidebar)
- React Router v7 for navigation
- xterm.js for terminal (Console + Shell modes)
- Catppuccin Mocha/Latte theming via JSON config files

**From UX Design - Server Lifecycle:**

- Server can be in "Not Installed" state with Install button and version input
- Installation progress stages: Downloading → Extracting → Verifying → Complete
- Version mismatch alert when installed differs from configured
- Server states: Not Installed, Installing, Installed (Stopped), Installed (Running), Upgrading, Error

**From UX Design - Pending Restart Pattern:**

- Changes requiring restart tracked server-side (`pendingRestart` state)
- Persistent header banner: "⟳ Restart required · N pending changes · [Restart Now]"
- Two workflows: immediate restart or batch changes

**From UX Design - Components:**

- ServerStatusBadge (6 states with icons)
- CompatibilityBadge (Compatible/Not verified/Incompatible)
- ModLookupInput (accepts slugs or URLs, debounced lookup)
- PendingRestartBanner (header component)
- TerminalView (xterm.js wrapper with Console/Shell tabs)
- ServerInstallCard (empty state for no server)
- InstallProgress (progress bar with stage labels)

**From UX Design - Accessibility:**

- WCAG 2.1 Level AA compliance
- Minimum 44x44px touch targets
- Keyboard navigation via Radix primitives
- ARIA live regions for dynamic content
- Respect `prefers-reduced-motion`

### FR Coverage Map

| FR | Epic | Description |
|----|------|-------------|
| FR1 | Epic 3 | Admin views server status |
| FR2 | Epic 3 | Admin starts server |
| FR3 | Epic 3 | Admin stops server |
| FR4 | Epic 3 | Admin restarts server |
| FR5 | Epic 3 | Monitor views server status |
| FR6 | Epic 4 | Admin views console stream |
| FR7 | Epic 4 | Admin scrolls console history |
| FR8 | Epic 4 | Admin sends console commands |
| FR9 | Epic 4 | Console restricted to Admin |
| FR10 | Epic 5 | Admin views mod list |
| FR11 | Epic 5 | Admin installs mod by slug |
| FR12 | Epic 5 | System validates compatibility |
| FR13 | Epic 5 | System shows compatibility warnings |
| FR14 | Epic 5 | Admin enables mod |
| FR15 | Epic 5 | Admin disables mod |
| FR16 | Epic 5 | Admin removes mod |
| FR17 | Epic 5 | Monitor views mod list |
| FR18 | Epic 6 | Admin views config file list |
| FR19 | Epic 6 | Admin reads config file |
| FR20 | Epic 6 | Admin edits config file |
| FR21 | Epic 6 | Monitor views config file list |
| FR22 | Epic 6 | Monitor reads config file |
| FR23 | Epic 7 | Admin views settings |
| FR24 | Epic 7 | Admin updates settings |
| FR25 | Epic 7 | Admin views whitelist |
| FR26 | Epic 7 | Admin manages whitelist |
| FR27 | Epic 1 | Health endpoint exposed |
| FR28 | Epic 1 | Readiness endpoint exposed |
| FR29 | Epic 1 | Health reports game server status |
| FR31 | Epic 2 | API key authentication |
| FR32 | Epic 2 | Monitor role support |
| FR33 | Epic 2 | Admin role support |
| FR34 | Epic 2 | Console restricted to Admin |
| FR35 | Epic 2 | Writes restricted to Admin |
| FR36 | Epic 2 | 401 for invalid key |
| FR37 | Epic 2 | 403 for insufficient role |
| FR38 | Epic 1 | docker-compose deployment |
| FR39 | Epic 1 | Environment variable config |

**Note:** FR30 (Metrics endpoint) is marked POST-MVP in PRD, not included in MVP epics.

### Post-MVP FR Coverage Map

| FR | Epic | Description |
|----|------|-------------|
| FR40 | Epic 9 | Secure WebSocket token auth |
| FR41 | Epic 9 | Short-lived token validation |
| FR42 | Epic 9 | Auto-create directories on startup |
| FR43 | Epic 9 | Log directory creation |
| FR44 | Epic 9 | Cache eviction strategy |
| FR45 | Epic 9 | Configurable cache limits |
| FR46 | Epic 9 | Log cache eviction events |
| FR47 | Epic 9 | Debug logging throughout services |
| FR48 | Epic 9 | Toggle debug via env var |
| FR49 | Epic 9 | Correlation IDs in debug logs |
| FR50 | Epic 9 | Distinct color for user commands |
| FR51 | Epic 9 | [CMD] prefix for commands |
| FR52 | Epic 9 | JSON syntax colorization |
| FR53 | Epic 9 | Distinct colors for JSON types |
| FR54 | Epic 9 | Show all directories in browser |
| FR55 | Epic 9 | Dynamic directory listing |
| FR56 | Epic 10 | Split Mods into tabs |
| FR57 | Epic 10 | Installed tab functionality |
| FR58 | Epic 10 | Browse tab experience |
| FR59 | Epic 10 | Default newest mods |
| FR60 | Epic 10 | Pre-filter compatible mods |
| FR61 | Epic 10 | Immediate content load |
| FR62 | Epic 10 | Keyword search |
| FR63 | Epic 10 | Debounced search |
| FR64 | Epic 10 | Maintain filters during search |
| FR65 | Epic 10 | Filter by side |
| FR66 | Epic 10 | Filter by tags |
| FR67 | Epic 10 | Filter by game version |
| FR68 | Epic 10 | Filter by mod type |
| FR69 | Epic 10 | Combined filters (AND) |
| FR70 | Epic 10 | Display/remove active filters |
| FR71 | Epic 10 | Sort options |
| FR72 | Epic 10 | Default sort: newest |
| FR73 | Epic 10 | Persist sort selection |
| FR74 | Epic 10 | Card display format |
| FR75 | Epic 10 | Compatibility badges on cards |
| FR76 | Epic 10 | Clickable cards to details |
| FR77 | Epic 10 | Full mod detail view |
| FR78 | Epic 10 | Install with version selection |
| FR79 | Epic 10 | Show installed status in detail |
| FR80 | Epic 10 | Pagination support |
| FR81 | Epic 10 | Infinite scroll or pages |
| FR82 | Epic 10 | Maintain position on return |
| FR83 | Epic 10 | Install from browse/detail |
| FR84 | Epic 10 | Show compatibility before install |
| FR85 | Epic 10 | Update UI after install |

## Epic List

### Epic 1: Project Foundation & Health Monitoring

Developers can set up the project using the defined starter template, and operations teams can verify the system is running via health endpoints. This epic establishes the scaffolding for all future development and provides the first deployable artifact.

**FRs covered:** FR27, FR28, FR29, FR38, FR39

**MVP Scope:**

- Project initialization per Architecture starter template (mise, uv, Bun)
- Backend scaffolding (FastAPI + dependencies)
- Frontend scaffolding (Vite + React + shadcn/ui)
- Health endpoints (`/healthz`, `/readyz`) without authentication
- docker-compose configuration
- Environment variable configuration pattern

---

### Epic 2: Authentication & API Security

API consumers can authenticate with appropriate role-based access, and the system enforces security boundaries between Admin and Monitor roles.

**FRs covered:** FR31, FR32, FR33, FR34, FR35, FR36, FR37

**MVP Scope:**

- API key authentication via `X-API-Key` header
- Admin role with full access
- Monitor role with read-only access to non-sensitive data
- Console access restricted to Admin only
- Proper 401/403 responses
- Security logging for failed auth attempts

---

### Epic 3: Server Lifecycle Management

Admins can install the VintageStory server by version number and control it (start, stop, restart) from the web UI. This is the first "real user value" epic.

**FRs covered:** FR1, FR2, FR3, FR4, FR5

**MVP Scope:**

- Server installation by version number (download tarball, extract, post-install setup)
- Download progress indication
- Server start/stop/restart controls
- Server status display (running/stopped, version, uptime)
- Dashboard with server controls
- ServerStatusBadge component
- ServerInstallCard for empty state

**Post-MVP (deferred):**

- Version switching/upgrade
- Rollback to previous version

---

### Epic 4: Real-Time Console Access

Admins can monitor game server output in real-time and send commands, enabling troubleshooting without container access.

**FRs covered:** FR6, FR7, FR8, FR9

**MVP Scope:**

- WebSocket console streaming
- Console history buffer (in-memory ring buffer)
- Command input to game server
- Admin-only access enforcement
- TerminalView component with xterm.js (Console mode)
- Auto-reconnection with exponential backoff

**Post-MVP (deferred):**

- Shell tab (PTY access)
- Console search

---

### Epic 5: Mod Management

Admins can install, enable/disable, and remove mods via the web UI with automatic compatibility validation. This is the "slug to success" experience - the defining user journey.

**FRs covered:** FR10, FR11, FR12, FR13, FR14, FR15, FR16, FR17

**MVP Scope:**

- Mod list with version and compatibility status
- Install mod by slug (or URL - parsed to slug)
- Compatibility validation against game version
- Compatibility warnings for unverified mods
- Enable/disable mods
- Remove mods
- Monitor read-only access to mod list
- ModLookupInput component
- CompatibilityBadge component
- Pending restart indication

**Post-MVP (deferred):**

- Mod update detection
- One-click updates
- Version switching/rollback

---

### Epic 6: Game Configuration Management

Admins can view and edit game server configuration files through the web UI, completing the "no terminal needed" promise.

**FRs covered:** FR18, FR19, FR20, FR21, FR22

**MVP Scope:**

- List game configuration files
- Read configuration file contents
- Edit and save configuration files (JSON)
- Monitor read-only access
- Config editor component
- Pending restart pattern for config changes

---

### Epic 7: Server Settings & Whitelist Management

Admins can manage server-level settings and control player access via whitelist.

**FRs covered:** FR23, FR24, FR25, FR26

**MVP Scope:**

- View server management settings
- Update settings (server name, whitelist mode, etc.)
- View player whitelist
- Add/remove players from whitelist
- Settings UI page

---

## Epic Summary

| Epic | Title | FRs | User Value |
|------|-------|-----|------------|
| 1 | Project Foundation & Health Monitoring | 5 | Deployable system with health checks |
| 2 | Authentication & API Security | 7 | Secure role-based API access |
| 3 | Server Lifecycle Management | 5 | Install and control game server |
| 4 | Real-Time Console Access | 4 | Monitor and command server in browser |
| 5 | Mod Management | 8 | Install mods by slug with compatibility |
| 6 | Game Configuration Management | 5 | Edit configs without file access |
| 7 | Server Settings & Whitelist | 4 | Manage settings and player access |
| **Total** | | **38** | |

## Dependency Flow

```
Epic 1 (Foundation)
    ↓
Epic 2 (Auth) ←── Required by all protected endpoints
    ↓
Epic 3 (Server Lifecycle) ←── First user value
    ↓
Epic 4 (Console) ←── Requires server to monitor
    ↓
Epic 5 (Mods) ←── Uses console for verification, server for restarts
    ↓
Epic 6 (Config) ←── Uses pending restart pattern
    ↓
Epic 7 (Settings) ←── Final admin capabilities
```

Each epic is standalone once complete and enables future epics without requiring them.

---

## Epic 1: Project Foundation & Health Monitoring

Developers can set up the project using the defined starter template, and operations teams can verify the system is running via health endpoints.

### Story 1.1: Initialize Development Environment and Project Structure

As a **developer**,
I want **a properly configured development environment with project scaffolding**,
So that **I can begin implementing features with consistent tooling across the team**.

**Acceptance Criteria:**

**Given** a fresh clone of the repository
**When** I run `mise trust && mise install`
**Then** Python 3.13, uv, and Bun are installed at the pinned versions
**And** a `.mise.toml` file exists at the project root with tool versions specified

**Given** the development environment is set up
**When** I navigate to the `api/` directory
**Then** a `pyproject.toml` exists with project name `vintagestory-api`
**And** dependencies include `fastapi[standard]`, `httpx`, `pydantic-settings`, `structlog`
**And** dev dependencies include `pytest`, `pytest-asyncio`, `ruff`, `respx`

**Given** the development environment is set up
**When** I navigate to the `web/` directory
**Then** a `package.json` exists with React 19.2 and TypeScript configured
**And** Tailwind CSS v4 is installed and configured
**And** shadcn/ui is initialized with the project's component configuration

**Given** the project structure is initialized
**When** I examine the repository root
**Then** the directory structure matches the Architecture specification
**And** `.gitignore` excludes appropriate files (node_modules, .venv, **pycache**, data/)

---

### Story 1.2: Backend API Skeleton with Health Endpoints

As an **operations engineer**,
I want **health check endpoints that report system status**,
So that **I can configure Kubernetes probes and monitoring systems**.

**Acceptance Criteria:**

**Given** the API server is running
**When** I send a GET request to `/healthz`
**Then** I receive a 200 status code
**And** the response follows the envelope format `{"status": "ok", "data": {...}}`
**And** no authentication is required
*(Covers FR27)*

**Given** the API server is running
**When** I send a GET request to `/readyz`
**Then** I receive a 200 status code when the API is ready to serve requests
**And** the response includes readiness information
**And** no authentication is required
*(Covers FR28)*

**Given** the API server is running
**When** I query the health endpoints
**Then** the response includes game server process status (running/stopped/not_installed)
**And** the API health is reported separately from game server health
*(Covers FR29, NFR15)*

**Given** the API server is running
**When** the game server process is not running
**Then** the API still responds to health checks (API healthy, game stopped)
*(Covers NFR8)*

**Given** any API request is made
**When** the server processes the request
**Then** structured JSON logs are emitted (in production mode)
**And** human-readable logs are emitted (in development mode)
*(Covers NFR14)*

---

### Story 1.3: Frontend Application Shell

As an **administrator**,
I want **a web interface with navigation and theming**,
So that **I can access server management features through a consistent UI**.

**Acceptance Criteria:**

**Given** I navigate to the web application
**When** the page loads
**Then** I see a sidebar with navigation items (Dashboard, Mods, Config, Terminal)
**And** I see a header displaying the server name placeholder
**And** the application uses Catppuccin Mocha theme by default (dark mode)

**Given** I am viewing the application
**When** I click the theme toggle in the header
**Then** the theme switches between Mocha (dark) and Latte (light)
**And** my preference is persisted in localStorage

**Given** I am viewing the application
**When** my system has `prefers-color-scheme: dark` or `light`
**Then** the initial theme respects my system preference (if no stored preference)

**Given** I am on any page
**When** I click a navigation item in the sidebar
**Then** the URL updates to reflect the selected section
**And** the main content area displays the corresponding view
**And** the active navigation item is visually highlighted

**Given** I am viewing the sidebar
**When** I click the collapse button
**Then** the sidebar collapses to icon-only mode (64px)
**And** my collapse preference is persisted in localStorage

**Given** I resize my browser to mobile width (<768px)
**When** the viewport is narrow
**Then** the sidebar is hidden by default
**And** a hamburger menu button appears to toggle the sidebar overlay

---

### Story 1.4: Docker Deployment Configuration

As a **server administrator**,
I want **to deploy the application using docker-compose**,
So that **I can run VintageStory Server Manager with minimal configuration**.

**Acceptance Criteria:**

**Given** I have Docker and docker-compose installed
**When** I run `docker compose up -d` with `docker-compose.yaml`
**Then** the container starts successfully
**And** the web UI is accessible on port 8080
**And** the health endpoints respond correctly
*(Covers FR38)*

**Given** the container is running
**When** I check the container logs
**Then** I see structured startup messages
**And** no errors are present for a clean start

**Given** I set environment variables (`VS_API_KEY_ADMIN`, etc.)
**When** the container starts
**Then** the application reads configuration from environment variables
**And** default values are used for optional unset variables
*(Covers FR39)*

**Given** a `docker-compose.dev.yaml` file exists
**When** I run `docker compose -f docker-compose.dev.yaml up --build`
**Then** the image builds from local source
**And** development defaults are applied (e.g., `VS_DEBUG=true`)

**Given** the container is running
**When** I examine the volume mounts
**Then** `/data` is mounted for persistent storage
**And** the directory structure matches Architecture specification (`/data/server/`, `/data/mods/`, `/data/state/`, etc.)

**Given** I have a `.env.example` file
**When** I review it
**Then** all configurable environment variables are documented with descriptions

---

## Epic 2: Authentication & API Security

API consumers can authenticate with appropriate role-based access, and the system enforces security boundaries between Admin and Monitor roles.

### Story 2.1: API Key Authentication Middleware

As an **API consumer**,
I want **to authenticate using an API key in the request header**,
So that **I can access protected endpoints securely**.

**Acceptance Criteria:**

**Given** I have a valid Admin API key
**When** I send a request with `X-API-Key: <valid-admin-key>` header
**Then** the request is authenticated successfully
**And** my role is identified as Admin
*(Covers FR31, FR33)*

**Given** I have a valid Monitor API key
**When** I send a request with `X-API-Key: <valid-monitor-key>` header
**Then** the request is authenticated successfully
**And** my role is identified as Monitor
*(Covers FR31, FR32)*

**Given** I send a request without an API key
**When** the endpoint requires authentication
**Then** I receive a 401 Unauthorized response
**And** the response body contains `{"status": "error", "error": {"code": "UNAUTHORIZED", "message": "..."}}`
*(Covers FR36)*

**Given** I send a request with an invalid API key
**When** the endpoint requires authentication
**Then** I receive a 401 Unauthorized response
**And** the failed attempt is logged with request context (but not the key value)
*(Covers FR36, NFR7)*

**Given** any authentication attempt occurs
**When** the system processes the request
**Then** API keys are never logged in plaintext
*(Covers NFR4)*

**Given** health endpoints (`/healthz`, `/readyz`)
**When** I send a request without authentication
**Then** the request succeeds (health endpoints remain unauthenticated)

---

### Story 2.2: Role-Based Access Control for API Endpoints

As a **system administrator**,
I want **different API keys to have different permission levels**,
So that **I can grant read-only access to monitoring systems while reserving write access for admins**.

**Acceptance Criteria:**

**Given** I am authenticated as Admin
**When** I attempt any API operation (read or write)
**Then** the operation is permitted
*(Covers FR33)*

**Given** I am authenticated as Monitor
**When** I attempt a read operation on non-sensitive endpoints
**Then** the operation is permitted
*(Covers FR32)*

**Given** I am authenticated as Monitor
**When** I attempt a write operation (POST, PUT, DELETE on protected resources)
**Then** I receive a 403 Forbidden response
**And** the response body contains `{"status": "error", "error": {"code": "FORBIDDEN", "message": "..."}}`
*(Covers FR35, FR37)*

**Given** I am authenticated as Monitor
**When** I attempt to access console endpoints (stream or history)
**Then** I receive a 403 Forbidden response
**And** the error message indicates console access requires Admin role
*(Covers FR34)*

**Given** role permissions are checked
**When** a 403 response is returned
**Then** the response clearly indicates the required role for the operation

---

### Story 2.3: Frontend API Client with Authentication

As a **frontend developer**,
I want **an API client that handles authentication and key transformation**,
So that **all API calls are properly authenticated and response data is correctly formatted**.

**Acceptance Criteria:**

**Given** the frontend application is configured
**When** API calls are made
**Then** the `X-API-Key` header is automatically included from configuration

**Given** the API returns a response with snake_case fields
**When** the API client processes the response
**Then** fields are transformed to camelCase for frontend consumption

**Given** the API returns a 401 Unauthorized response
**When** the frontend receives the error
**Then** an appropriate error state is displayed to the user
**And** the user is informed that authentication failed

**Given** the API returns a 403 Forbidden response
**When** the frontend receives the error
**Then** an appropriate error state is displayed
**And** the user is informed they lack permission for the operation

**Given** TanStack Query is configured
**When** API calls are made
**Then** server state is managed through TanStack Query hooks
**And** client-only state (theme, sidebar) uses React Context

---

## Epic 3: Server Lifecycle Management

Admins can install the VintageStory server by version number and control it (start, stop, restart) from the web UI.

### Story 3.1: Server Installation Service

As an **administrator**,
I want **to install the VintageStory server by providing a version number**,
So that **I can get a game server running without manual file management**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I call `POST /api/v1alpha1/server/install` with `{"version": "1.21.3"}`
**Then** the system downloads the server tarball from the VintageStory CDN
**And** extracts it to `/data/server/`
**And** creates a symlink from `/data/server/Mods` to `/data/mods/`
**And** copies default config if none exists

**Given** a server installation is in progress
**When** I query `GET /api/v1alpha1/server/install/status`
**Then** I receive progress information (stage: downloading/extracting/configuring, percentage if available)

**Given** the download fails (network error, invalid version)
**When** the installation process encounters the error
**Then** the error is reported clearly with actionable message
**And** the system returns to "not installed" state

**Given** the version format is invalid
**When** I attempt installation
**Then** I receive a 400 Bad Request with validation error details

**Given** a server is already installed
**When** I attempt to install again
**Then** I receive an error indicating server already exists (version switching is post-MVP)

---

### Story 3.2: Server Lifecycle Control API

As an **administrator**,
I want **to start, stop, and restart the game server via API**,
So that **I can control the server without container access**.

**Acceptance Criteria:**

**Given** a server is installed and stopped
**When** I call `POST /api/v1alpha1/server/start`
**Then** the game server process starts
**And** the response confirms the action was initiated
*(Covers FR2)*

**Given** a server is running
**When** I call `POST /api/v1alpha1/server/stop`
**Then** the game server receives a graceful shutdown signal
**And** the process terminates cleanly
**And** the response confirms the action was initiated
*(Covers FR3)*

**Given** a server is running
**When** I call `POST /api/v1alpha1/server/restart`
**Then** the server stops gracefully and starts again
**And** the response confirms the restart was initiated
*(Covers FR4)*

**Given** no server is installed
**When** I attempt to start/stop/restart
**Then** I receive a 400 Bad Request indicating no server is installed

**Given** the server process crashes unexpectedly
**When** the API detects the crash
**Then** the server status updates to "stopped" with exit code information
**And** the API remains available and responsive
*(Covers NFR8, NFR9)*

---

### Story 3.3: Server Status API

As an **administrator or monitor**,
I want **to view the current server status**,
So that **I can see if the server is running and its version**.

**Acceptance Criteria:**

**Given** the API is running
**When** I call `GET /api/v1alpha1/server/status` as Admin
**Then** I receive server status including: state (not_installed/stopped/starting/running/stopping), version, uptime (if running)
*(Covers FR1)*

**Given** the API is running
**When** I call `GET /api/v1alpha1/server/status` as Monitor
**Then** I receive the same status information (read-only access permitted)
*(Covers FR5)*

**Given** the server is running
**When** I query status
**Then** uptime is calculated from process start time
**And** version is read from the installed server

**Given** the server is not installed
**When** I query status
**Then** state is "not_installed"
**And** version and uptime are null

---

### Story 3.4: Dashboard with Server Controls UI

As an **administrator**,
I want **a dashboard showing server status with control buttons**,
So that **I can monitor and control the server from the web interface**.

**Acceptance Criteria:**

**Given** no server is installed
**When** I view the Dashboard
**Then** I see the ServerInstallCard with version input and "Install Server" button
**And** server control buttons (Start/Stop/Restart) are not visible

**Given** a server installation is in progress
**When** I view the Dashboard
**Then** I see a progress indicator with current stage and percentage
**And** the install button is disabled

**Given** a server is installed and stopped
**When** I view the Dashboard
**Then** I see the ServerStatusBadge showing "Stopped" (red)
**And** server version is displayed
**And** "Start" button is enabled
**And** "Stop" and "Restart" buttons are disabled

**Given** a server is running
**When** I view the Dashboard
**Then** I see the ServerStatusBadge showing "Running" (green)
**And** server version and uptime are displayed
**And** "Stop" and "Restart" buttons are enabled
**And** "Start" button is disabled

**Given** I click a server control button
**When** the action is in progress
**Then** the button shows a loading state
**And** a toast notification appears on success or failure

**Given** the server state changes
**When** the Dashboard is open
**Then** the status updates automatically without page refresh (TanStack Query polling or refetch)

---

## Epic 4: Real-Time Console Access

Admins can monitor game server output in real-time and send commands, enabling troubleshooting without container access.

### Story 4.1: Console Buffer Service

As a **backend developer**,
I want **an in-memory ring buffer that captures game server output**,
So that **console history is available for streaming and retrieval**.

**Acceptance Criteria:**

**Given** the game server is running
**When** it produces stdout/stderr output
**Then** the output is captured and stored in the ring buffer
**And** timestamps are added to each line

**Given** the ring buffer has a configured size (default 10,000 lines)
**When** new output exceeds the buffer capacity
**Then** the oldest lines are discarded (FIFO)

**Given** the console buffer contains data
**When** the API server restarts
**Then** the buffer is empty (in-memory only, no disk persistence)
*(Covers NFR6)*

**Given** the game server crashes or stops
**When** the admin queries console history
**Then** the buffer contents up to the crash are preserved
**And** available for troubleshooting

---

### Story 4.2: WebSocket Console Streaming

As an **administrator**,
I want **to receive real-time console output via WebSocket**,
So that **I can monitor server activity as it happens**.

**Acceptance Criteria:**

**Given** I am authenticated as Admin
**When** I connect to `ws://host/api/v1alpha1/console` with `?api_key=<admin-key>`
**Then** the WebSocket connection is established
**And** I begin receiving console output in real-time
*(Covers FR6)*

**Given** I am connected to the console WebSocket
**When** the game server produces output
**Then** I receive the output within 1 second
*(Covers NFR1)*

**Given** I connect to the console WebSocket
**When** the connection is established
**Then** I receive the recent buffer history (configurable, e.g., last 100 lines)
*(Covers FR7)*

**Given** I am authenticated as Monitor
**When** I attempt to connect to the console WebSocket
**Then** the connection is rejected with 403 Forbidden
*(Covers FR9)*

**Given** I have no API key or an invalid key
**When** I attempt to connect to the console WebSocket
**Then** the connection is rejected with 401 Unauthorized

**Given** the WebSocket connection is lost
**When** the client reconnects
**Then** recent buffer history is sent to fill the gap

---

### Story 4.3: Console Command Input

As an **administrator**,
I want **to send commands to the game server through the console**,
So that **I can interact with the server without container access**.

**Acceptance Criteria:**

**Given** I am connected to the console WebSocket as Admin
**When** I send a message with type "command" and content "/help"
**Then** the command is written to the game server's stdin
**And** the command response appears in the console stream
*(Covers FR8)*

**Given** I send a command
**When** the server processes it
**Then** my sent command is echoed back (or marked) in the stream for confirmation

**Given** the game server is not running
**When** I attempt to send a command
**Then** I receive an error message indicating the server is stopped

**Given** I am authenticated as Monitor
**When** I attempt to send a command via any mechanism
**Then** the request is rejected with 403 Forbidden
*(Covers FR9)*

---

### Story 4.4: Terminal View Component

As an **administrator**,
I want **a terminal interface in the web UI showing console output**,
So that **I can view and interact with the server console visually**.

**Acceptance Criteria:**

**Given** I navigate to the Terminal page as Admin
**When** the page loads
**Then** I see an xterm.js terminal component
**And** it connects to the console WebSocket automatically
**And** displays incoming console output with Catppuccin theming

**Given** the terminal is connected
**When** new console output arrives
**Then** it appears in the terminal view immediately
**And** the terminal auto-scrolls to show new content

**Given** I am viewing the terminal
**When** I scroll up in the terminal
**Then** I can view console history from the buffer
*(Covers FR7)*

**Given** I type in the terminal and press Enter
**When** the command is submitted
**Then** it is sent via the WebSocket command mechanism
**And** I see the command and its response in the terminal
*(Covers FR8)*

**Given** the WebSocket connection is lost
**When** the terminal detects disconnection
**Then** a "Disconnected" indicator is shown
**And** the terminal attempts to reconnect with exponential backoff (max 30s, 10 retries)
*(Covers NFR10)*

**Given** reconnection succeeds
**When** the terminal reconnects
**Then** recent history is loaded to fill the gap
**And** the "Disconnected" indicator is removed

**Given** I am authenticated as Monitor
**When** I navigate to the Terminal page
**Then** I see a message indicating console access requires Admin role
**And** no terminal is displayed

---

## Epic 5: Mod Management

Admins can install, enable/disable, and remove mods via the web UI with automatic compatibility validation.

### Story 5.0: Epic 5 Technical Preparation

As a **development team**,
I want **to complete technical preparation for Epic 5 (Mod Management)**,
So that **we have updated architecture docs, caching patterns, and refactored tests before implementing mod features**.

**Background:** This preparatory story was defined during the Epic 4 retrospective. Epic 5 introduces external API dependencies and new UI patterns that benefit from upfront research and infrastructure improvements.

**Acceptance Criteria:**

**Given** the architecture documentation is reviewed
**When** I read the architecture.md file
**Then** it reflects current implementation state and any needed updates for Epic 5

**Given** a manual test checklist exists
**When** I review `docs/manual-test-checklist.md`
**Then** it contains smoke tests for Epics 1-4 functionality and placeholders for Epic 5

**Given** the mod API patterns are verified
**When** I review `agentdocs/modstoryapi.md`
**Then** it contains current API patterns with working examples verified against the live API

**Given** pending restart pattern research is complete
**When** I review the research findings
**Then** it documents the UI pattern for tracking changes requiring server restart

**Given** caching strategy research is complete
**When** I review the caching documentation
**Then** it covers artifact caching (server tarballs) and API response caching (mod data, TTL-based)

**Given** large test files are refactored
**When** I examine `api/tests/`
**Then** `test_console.py` and `test_server.py` are split into focused modules

**Tasks:**

- [ ] Task 1: Architecture doc review and update
- [ ] Task 2: Manual test checklist creation (`docs/manual-test-checklist.md`)
- [ ] Task 3: Mod API integration patterns verification
- [ ] Task 4: Pending restart pattern research
- [ ] Task 5: Caching strategy research (artifacts + API responses)
- [ ] Task 6: Refactor large test files into focused modules

---

### Story 5.1: Mod Service and State Management

As a **backend developer**,
I want **a service that tracks installed mods and their state**,
So that **mod information is persisted and available to the API**.

**Acceptance Criteria:**

**Given** mods are installed in `/data/mods/`
**When** the API starts or rescans
**Then** the mod service discovers all `.zip` files in the mods directory
**And** extracts mod metadata (modid, version, name) from `modinfo.json`

**Given** a mod's enabled/disabled state changes
**When** the state is updated
**Then** the change is persisted to `/data/state/state.json` (atomic write)
**And** a pending restart flag is set if the server is running

**Given** state persistence fails
**When** an atomic write is attempted
**Then** the temp file is written first, then renamed (prevents corruption)

---

### Story 5.2: Mod Installation API

As an **administrator**,
I want **to install a mod by entering its slug**,
So that **I don't need to manually download and copy mod files**.

**Acceptance Criteria:**

**Given** I call `POST /api/v1alpha1/mods` with `{"slug": "smithingplus"}`
**When** the mod exists on mods.vintagestory.at
**Then** the latest release is downloaded to `/data/mods/`
**And** the mod appears in the installed mods list
*(Covers FR11)*

**Given** I provide a full URL instead of a slug
**When** I call the install endpoint with `{"slug": "https://mods.vintagestory.at/smithingplus"}`
**Then** the slug is extracted from the URL and installation proceeds

**Given** the mod slug does not exist
**When** I attempt installation
**Then** I receive a 404 error with message "Mod not found"

**Given** the VintageStory mod API is unavailable
**When** I attempt installation
**Then** I receive a 502 error with clear message about external API failure
*(Covers NFR11)*

**Given** the download fails mid-transfer
**When** the error occurs
**Then** partial files are cleaned up
**And** a clear error message is returned
*(Covers NFR12)*

---

### Story 5.3: Mod Compatibility Validation

As an **administrator**,
I want **to see mod compatibility before installation**,
So that **I can make informed decisions about installing mods**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods/lookup/{slug}`
**When** the mod exists
**Then** I receive mod details including: name, description, latest version, and compatibility status

**Given** the installed game server version is 1.21.3
**When** I look up a mod with release tagged for "1.21.3"
**Then** compatibility status is "compatible"
*(Covers FR12)*

**Given** the installed game server version is 1.21.3
**When** I look up a mod with latest release tagged for "1.21.0"
**Then** compatibility status is "not_verified"
**And** a warning message indicates the mod wasn't explicitly tested for this version
*(Covers FR13)*

**Given** the installed game server version is 1.21.3
**When** I look up a mod with release tagged for "1.20.x" only
**Then** compatibility status is "incompatible"
**And** a warning message indicates version mismatch

**Given** I install a mod with "not_verified" or "incompatible" status
**When** the installation completes
**Then** the mod is installed (user made informed choice)
**And** the compatibility status is stored with the mod record

---

### Story 5.4: Mod Enable/Disable and Remove API

As an **administrator**,
I want **to enable, disable, and remove installed mods**,
So that **I can manage which mods are active without deleting files**.

**Acceptance Criteria:**

**Given** a mod is installed and enabled
**When** I call `POST /api/v1alpha1/mods/{slug}/disable`
**Then** the mod is marked as disabled in state
**And** the mod file is moved/renamed to indicate disabled status (e.g., `.disabled` suffix)
**And** a pending restart flag is set
*(Covers FR15)*

**Given** a mod is installed and disabled
**When** I call `POST /api/v1alpha1/mods/{slug}/enable`
**Then** the mod is marked as enabled in state
**And** the mod file is restored to active status
**And** a pending restart flag is set
*(Covers FR14)*

**Given** a mod is installed
**When** I call `DELETE /api/v1alpha1/mods/{slug}`
**Then** the mod file is deleted from `/data/mods/`
**And** the mod is removed from state
**And** a pending restart flag is set
*(Covers FR16)*

**Given** the mod slug doesn't exist in installed mods
**When** I attempt enable/disable/remove
**Then** I receive a 404 error

---

### Story 5.5: Mod List API

As an **administrator or monitor**,
I want **to view a list of installed mods with their status**,
So that **I can see what mods are installed and their compatibility**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods` as Admin
**When** mods are installed
**Then** I receive a list of installed mods with: slug, name, version, enabled status, compatibility status
*(Covers FR10)*

**Given** I call `GET /api/v1alpha1/mods` as Monitor
**When** mods are installed
**Then** I receive the same list (read-only access permitted)
*(Covers FR17)*

**Given** no mods are installed
**When** I query the mod list
**Then** I receive an empty array

**Given** the pending restart flag is set
**When** I query the mod list
**Then** the response includes `pending_restart: true` indicator

---

### Story 5.6: Mod Management UI

As an **administrator**,
I want **a web interface for managing mods**,
So that **I can install, view, and manage mods visually**.

**Acceptance Criteria:**

**Given** I navigate to the Mods page
**When** the page loads
**Then** I see a ModLookupInput field with placeholder "Enter mod slug or paste URL"
**And** I see a table of installed mods (or empty state if none)

**Given** I type a mod slug in the input
**When** I stop typing (300ms debounce)
**Then** a lookup request is made
**And** mod details appear in a preview card below the input

**Given** the mod lookup returns results
**When** I view the preview card
**Then** I see mod name, description, and CompatibilityBadge (green/yellow/red)
**And** an "Install" button is available

**Given** I click "Install" on a compatible mod
**When** installation completes
**Then** a success toast appears
**And** the mod appears in the installed mods table
**And** the pending restart banner appears in the header

**Given** I click "Install" on an incompatible mod
**When** I click the button
**Then** a warning dialog appears asking for confirmation
**And** I can choose to proceed or cancel

**Given** the mods table is displayed
**When** I view an installed mod row
**Then** I see: mod name, installed version, compatibility badge, enabled/disabled toggle, remove button

**Given** I toggle a mod's enabled state
**When** the toggle is clicked
**Then** the state updates optimistically
**And** a toast confirms success or shows error
**And** pending restart indicator updates

**Given** I click the remove button on a mod
**When** the confirmation dialog appears and I confirm
**Then** the mod is removed from the list
**And** a success toast appears

---

## Epic 6: Game Configuration Management

Admins can configure game server settings through the web UI using console commands for live updates. The Console tab is renamed to GameServer and includes both console output and a configuration panel side-by-side. API operational settings are managed separately in a new Settings tab.

**Architectural Pivot (2025-12-30):** Original file-editing approach replaced with console command pattern. VintageStory server handles JSON persistence automatically when settings are changed via `/serverconfig` commands.

**Key Decisions:**
- `/config/game` - Game server settings (console commands for live update)
- `/config/api` - API operational settings (auto_start, refresh intervals)
- ConfigInitService - First-run config generation from template + VS_CFG_* env vars
- Console tab → GameServer tab with responsive split layout
- TanStack Table for data lists, Zod + custom hooks for field validation

---

### Story 6.0: Epic 6 Technical Preparation

As a **developer**,
I want **to research VintageStory console commands and create configuration infrastructure**,
So that **subsequent stories have a solid foundation for config management**.

**Acceptance Criteria:**

**Given** we need to understand console command behavior
**When** I research the `/serverconfig` command
**Then** I document which settings support live update vs require restart
**And** I verify that console changes persist to serverconfig.json automatically

**Given** we need a reference configuration template
**When** I analyze DarkMatterProductions and VintageStory defaults
**Then** I create `serverconfig-template.json` with sensible defaults
**And** the template includes all common settings with documentation comments removed

**Given** we need to support VS_CFG_* environment variables
**When** I define the environment variable mapping
**Then** I document the complete ENV_VAR_MAP (VS_CFG_SERVER_NAME → ServerName, etc.)
**And** I verify the mapping covers all settings from the reference implementation

**Given** we need TanStack Table for data lists
**When** I add the dependency
**Then** `@tanstack/react-table` is added to web/package.json
**And** a basic table component pattern is documented

**Tasks:**
- [ ] Research `/serverconfig` command - document supported settings
- [ ] Test console command persistence - verify JSON auto-save
- [ ] Create `serverconfig-template.json` from DarkMatterProductions reference
- [ ] Define complete VS_CFG_* → serverconfig.json key mapping
- [ ] Add TanStack Table dependency to web project
- [ ] Update architecture.md with research findings

---

### Story 6.1: ConfigInitService and Template

As an **administrator**,
I want **the server to automatically generate an initial configuration from environment variables**,
So that **I can deploy with custom settings without manual file creation**.

**Acceptance Criteria:**

**Given** the game server is installed but no serverconfig.json exists
**When** the server start is requested
**Then** ConfigInitService generates serverconfig.json from the template
**And** any VS_CFG_* environment variables override template defaults

**Given** VS_CFG_SERVER_NAME is set to "My Custom Server"
**When** ConfigInitService generates the config
**Then** serverconfig.json contains `"ServerName": "My Custom Server"`

**Given** VS_CFG_MAX_CLIENTS is set to "32"
**When** ConfigInitService generates the config
**Then** serverconfig.json contains `"MaxClients": 32` (integer, not string)

**Given** serverconfig.json already exists
**When** the server start is requested
**Then** ConfigInitService does NOT overwrite the existing config
**And** the existing config is used as-is

**Given** an invalid VS_CFG_* value is provided (e.g., VS_CFG_MAX_CLIENTS="abc")
**When** ConfigInitService processes environment variables
**Then** the invalid value is logged as a warning
**And** the template default is used instead

**Tasks:**
- [ ] Create ConfigInitService class with needs_initialization() and initialize_config()
- [ ] Implement ENV_VAR_MAP with type coercion (string, int, bool)
- [ ] Ship serverconfig-template.json in api package
- [ ] Integrate with ServerService.start() - call before server launch
- [ ] Add comprehensive tests for env var processing
- [ ] Test atomic write pattern (temp file + rename)

---

### Story 6.2: Game Settings API

As an **administrator**,
I want **to view and update game server settings through the API**,
So that **I can configure the server using console commands for live updates**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/config/game` as Admin or Monitor
**When** serverconfig.json exists
**Then** I receive settings with metadata (key, value, type, live_update, env_managed)
**And** the response includes source_file and last_modified

**Given** I call `POST /api/v1alpha1/config/game/settings/ServerName` with `{"value": "New Name"}`
**When** the game server is running
**Then** the API executes `/serverconfig Name "New Name"` via console
**And** the response includes `method: "console_command"` and `pending_restart: false`

**Given** I call `POST /api/v1alpha1/config/game/settings/Port` with `{"value": 42421}`
**When** the game server is running
**Then** the setting is written to serverconfig.json (Port requires restart)
**And** the response includes `method: "file_update"` and `pending_restart: true`

**Given** I attempt to update a setting managed by VS_CFG_* environment variable
**When** block_env_managed_settings is true (default)
**Then** I receive a 400 error with code SETTING_ENV_MANAGED
**And** the error message identifies the controlling environment variable

**Given** I am authenticated as Monitor
**When** I attempt to POST a setting update
**Then** I receive a 403 Forbidden

**Tasks:**
- [ ] Create GameConfigService with get_settings() and update_setting()
- [ ] Implement LIVE_SETTINGS map with console command templates
- [ ] Add /config/game router with GET and POST endpoints
- [ ] Integrate with ConsoleService for command execution
- [ ] Add pending restart state integration
- [ ] Comprehensive tests for live vs restart-required settings

---

### Story 6.3: API Settings Service

As an **administrator**,
I want **to view and update API operational settings**,
So that **I can configure auto-start, refresh intervals, and environment handling**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/config/api` as Admin
**When** api-settings.json exists (or defaults are used)
**Then** I receive current API settings: auto_start_server, block_env_managed_settings, refresh intervals

**Given** I call `POST /api/v1alpha1/config/api/settings/auto_start_server` with `{"value": true}`
**When** the request is valid
**Then** the setting is saved to api-settings.json
**And** the response confirms the update

**Given** I update mod_list_refresh_interval
**When** the scheduler is running (Epic 7+)
**Then** the job is rescheduled with the new interval

**Given** I am authenticated as Monitor
**When** I call GET /api/v1alpha1/config/api
**Then** I receive a 403 Forbidden (API settings are Admin-only)

**Tasks:**
- [ ] Create ApiSettingsService with get_settings() and update_setting()
- [ ] Define ApiSettings Pydantic model with defaults
- [ ] Implement api-settings.json persistence with atomic writes
- [ ] Add /config/api router with GET and POST endpoints
- [ ] Add setting validation (e.g., intervals must be positive)

---

### Story 6.4: Settings UI

As an **administrator**,
I want **a web interface for managing game and API settings**,
So that **I can configure the server visually and see console command feedback**.

**Acceptance Criteria:**

**Given** I navigate to the GameServer tab as Admin
**When** the page loads on desktop (≥1024px)
**Then** I see Game Config panel on left and Console on right (split view)

**Given** I navigate to the GameServer tab on mobile (<1024px)
**When** the page loads
**Then** I see Console on top and Game Config below (stacked, scrollable)

**Given** I change the ServerName field in Game Config
**When** I blur the field (auto-save)
**Then** the API is called and I see the `/serverconfig` command execute in Console
**And** a success toast appears

**Given** I change a restart-required setting (e.g., Port)
**When** the save completes
**Then** the PendingRestartBanner appears (consistent with mod changes)

**Given** a setting is managed by VS_CFG_* environment variable
**When** I view the setting
**Then** it shows an "Env: VS_CFG_*" badge and the input is disabled

**Given** I navigate to the Settings tab
**When** the page loads
**Then** I see tabs for "API Settings" and "File Manager"
**And** API Settings shows auto_start, env handling, and refresh intervals
**And** File Manager shows a "coming soon" stub

**Tasks:**
- [ ] Rename Console → GameServer in navigation
- [ ] Create GameServerPage with responsive split layout
- [ ] Create GameConfigPanel with SettingGroup and SettingField components
- [ ] Implement useSettingField hook with Zod validation
- [ ] Create SettingsPage with API Settings and File Manager tabs
- [ ] Create ApiSettingsPanel component
- [ ] Add File Manager stub component

---

### Story 6.5: Raw Config Viewer

As an **administrator or monitor**,
I want **read-only access to raw configuration files**,
So that **I can troubleshoot configuration issues**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/config/files` as Admin or Monitor
**When** config files exist in the data directory
**Then** I receive a list of configuration file names

**Given** I call `GET /api/v1alpha1/config/files/serverconfig.json`
**When** the file exists
**Then** I receive the raw JSON content

**Given** I request a file with path traversal (e.g., `../secrets.json`)
**When** the API validates the path
**Then** I receive a 400 error and the request is rejected

**Note:** This story provides the backend for the File Manager UI (stub in 6.4). Full File Manager UI is deferred to a future epic.

**Tasks:**
- [ ] Create /config/files router with list and read endpoints
- [ ] Implement path validation to prevent traversal attacks
- [ ] Add Monitor + Admin role access
- [ ] Add tests for path traversal prevention

---

## Epic 7: APScheduler Integration

The API server can execute periodic background tasks using APScheduler, enabling features like cache refresh and version checking.

**Added (2025-12-30):** New epic for background task scheduling infrastructure.

**Key Decisions:**
- APScheduler with AsyncIOScheduler and MemoryJobStore
- No external dependencies (in-memory job store)
- SchedulerService pattern with lifespan integration
- Job management API for visibility

---

### Story 7.0: Epic 7 Preparation

As a **developer**,
I want **to research APScheduler patterns and async integration**,
So that **subsequent stories have a solid foundation for scheduling**.

**Acceptance Criteria:**

**Given** we need to understand APScheduler async patterns
**When** I research the library
**Then** I document AsyncIOScheduler configuration best practices
**And** I verify compatibility with our FastAPI lifespan pattern

**Given** we need to add APScheduler
**When** I add the dependency
**Then** `apscheduler` is added to api/pyproject.toml
**And** version is pinned appropriately

**Tasks:**
- [ ] Research APScheduler AsyncIOScheduler patterns
- [ ] Add apscheduler dependency to pyproject.toml
- [ ] Document job defaults (coalesce, max_instances, misfire_grace_time)

---

### Story 7.1: SchedulerService

As a **developer**,
I want **a scheduler service that manages periodic background tasks**,
So that **jobs can be added, removed, and monitored**.

**Acceptance Criteria:**

**Given** the API server starts
**When** the lifespan context initializes
**Then** the SchedulerService starts the AsyncIOScheduler
**And** a log entry confirms "scheduler_started"

**Given** the API server shuts down
**When** the lifespan context exits
**Then** the SchedulerService stops the scheduler gracefully
**And** running jobs complete before shutdown

**Given** I need to add an interval job
**When** I call scheduler.add_interval_job(func, seconds, job_id)
**Then** the job is registered and will execute at the specified interval

**Given** I need to add a cron job
**When** I call scheduler.add_cron_job(func, cron_expression, job_id)
**Then** the job is registered with the cron schedule

**Tasks:**
- [ ] Create SchedulerService class with start/shutdown methods
- [ ] Implement add_interval_job and add_cron_job methods
- [ ] Integrate with FastAPI lifespan in main.py
- [ ] Add structured logging for scheduler events
- [ ] Add tests for scheduler lifecycle

---

### Story 7.2: Job Management API

As an **administrator**,
I want **to view and manage scheduled jobs through the API**,
So that **I can monitor background task status**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/jobs` as Admin
**When** jobs are registered
**Then** I receive a list of jobs with: id, next_run_time, interval/cron, last_run_status

**Given** I call `DELETE /api/v1alpha1/jobs/{job_id}` as Admin
**When** the job exists
**Then** the job is removed from the scheduler
**And** the response confirms deletion

**Given** I am authenticated as Monitor
**When** I call GET /api/v1alpha1/jobs
**Then** I receive a 403 Forbidden (job management is Admin-only)

**Tasks:**
- [ ] Create /jobs router with list and delete endpoints
- [ ] Implement job serialization (id, schedule, status)
- [ ] Add Admin-only authorization
- [ ] Add tests for job API

---

### Story 7.3: Scheduler Health

As an **operator**,
I want **scheduler status included in health checks**,
So that **I can monitor the background task system**.

**Acceptance Criteria:**

**Given** I call `GET /healthz`
**When** the scheduler is running
**Then** the response includes `scheduler: { status: "running", job_count: N }`

**Given** the scheduler has failed to start
**When** I call /healthz
**Then** the response includes `scheduler: { status: "stopped" }`

**Tasks:**
- [ ] Add scheduler status to health endpoint
- [ ] Include job count in health response
- [ ] Add tests for scheduler health reporting

---

## Epic 8: Periodic Task Patterns

Initial periodic jobs are implemented using the APScheduler infrastructure, enabling automated cache refresh and version checking.

**Added (2025-12-30):** New epic for implementing periodic jobs.

---

### Story 8.0: Epic 8 Preparation

As a **developer**,
I want **to define job patterns and error handling strategy**,
So that **periodic tasks are implemented consistently**.

**Acceptance Criteria:**

**Given** we need a standard job pattern
**When** I define the template
**Then** jobs follow a consistent structure: try/except, structured logging, no re-raise

**Given** we need job registration patterns
**When** I define the approach
**Then** jobs are registered in a central register_default_jobs() function
**And** registration respects API settings (interval values)

**Tasks:**
- [ ] Define standard job template in architecture
- [ ] Create jobs/ directory structure
- [ ] Implement register_default_jobs() function

---

### Story 8.1: Mod Cache Refresh Job

As an **administrator**,
I want **the mod API cache to refresh automatically**,
So that **mod information stays current without manual intervention**.

**Acceptance Criteria:**

**Given** mod_list_refresh_interval is set to 3600 (1 hour)
**When** the scheduler runs
**Then** the mod cache refresh job executes every hour

**Given** the mod API is unreachable during refresh
**When** the job executes
**Then** the error is logged but the job continues on schedule
**And** stale cache data is preserved

**Given** mod_list_refresh_interval is set to 0
**When** the scheduler starts
**Then** the mod cache refresh job is NOT registered

**Tasks:**
- [ ] Create refresh_mod_cache job function
- [ ] Register job in register_default_jobs()
- [ ] Add error handling and logging
- [ ] Add tests for job execution

---

### Story 8.2: Server Versions Check Job

As an **administrator**,
I want **automatic checks for new VintageStory versions**,
So that **I'm notified when updates are available**.

**Acceptance Criteria:**

**Given** server_versions_refresh_interval is set to 86400 (24 hours)
**When** the scheduler runs
**Then** the version check job executes daily

**Given** a new version is available
**When** the job detects it
**Then** the new version is logged
**And** the version info is available via status API

**Tasks:**
- [ ] Create check_server_versions job function
- [ ] Register job in register_default_jobs()
- [ ] Store latest version info for status API
- [ ] Add tests for version checking

---

### Story 8.3: Job Configuration UI

As an **administrator**,
I want **to view scheduled jobs in the Settings UI**,
So that **I can monitor background task status**.

**Acceptance Criteria:**

**Given** I navigate to the Settings page
**When** the page loads
**Then** I see a "Scheduled Jobs" section showing registered jobs

**Given** jobs are displayed
**When** I view a job
**Then** I see: job name, interval/schedule, next run time, last status

**Tasks:**
- [ ] Add jobs section to SettingsPage
- [ ] Create JobsTable component using TanStack Table
- [ ] Add useJobs query hook
- [ ] Style with badges for status (running, scheduled, failed)

---

## Story Summary

| Epic | Stories | Total |
|------|---------|-------|
| Epic 1: Project Foundation & Health Monitoring | 1.1, 1.2, 1.3, 1.4 | 4 |
| Epic 2: Authentication & API Security | 2.1, 2.2, 2.3 | 3 |
| Epic 3: Server Lifecycle Management | 3.1, 3.2, 3.3, 3.4, 3.5 | 5 |
| Epic 4: Real-Time Console Access | 4.0, 4.1, 4.2, 4.3, 4.4 | 5 |
| Epic 5: Mod Management | 5.0, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6 | 7 |
| Epic 6: Game Configuration Management | 6.0, 6.1, 6.2, 6.3, 6.4, 6.5 | 6 |
| Epic 7: APScheduler Integration | 7.0, 7.1, 7.2, 7.3 | 4 |
| Epic 8: Periodic Task Patterns | 8.0, 8.1, 8.2, 8.3 | 4 |
| Epic 9: Quality of Life Polish Pass | 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7 | 7 |
| Epic 10: Advanced Mod Browser | 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8 | 8 |
| **Total** | | **53** |

---

## Epic 9: Quality of Life Polish Pass

Admins benefit from security improvements, better debugging capabilities, and enhanced UI features that improve daily operations and troubleshooting.

**FRs covered:** FR40, FR41, FR42, FR43, FR44, FR45, FR46, FR47, FR48, FR49, FR50, FR51, FR52, FR53, FR54, FR55

**MVP Scope:**

- Secure WebSocket token authentication (replaces API key in URL)
- Directory auto-creation on startup
- Mod cache eviction strategy
- Debug logging with correlation IDs
- Console command highlighting with [CMD] prefix
- JSON syntax colorization in file viewer
- Dynamic directory listing in file browser

---

### Story 9.1: Secure WebSocket Authentication

As an **administrator**,
I want **WebSocket connections to use secure token authentication**,
So that **my API key is not exposed in URL query parameters**.

**Acceptance Criteria:**

**Given** I need to connect to the console WebSocket
**When** I request a connection token via `POST /api/v1alpha1/auth/ws-token`
**Then** I receive a short-lived token (e.g., 30 second TTL)
**And** the response includes `{"token": "<jwt-or-opaque-token>", "expires_in": 30}`
*(Covers FR40)*

**Given** I have a valid WebSocket token
**When** I connect to `ws://host/api/v1alpha1/console?token=<token>`
**Then** the connection is established successfully
**And** the token is validated server-side
*(Covers FR41)*

**Given** I attempt to connect with an expired token
**When** the token TTL has passed
**Then** the WebSocket connection is rejected with 401

**Given** the frontend needs to connect to the console
**When** the Terminal component mounts
**Then** it first requests a token, then connects with that token
**And** token refresh is handled automatically before expiry

---

### Story 9.2: Directory Auto-Creation on Startup

As an **operator**,
I want **the API server to create required directories on startup**,
So that **I don't encounter errors from missing directories**.

**Acceptance Criteria:**

**Given** the API server starts
**When** expected directories don't exist under `/data/vsmanager/`
**Then** the directories are created: `cache/`, `state/`, `logs/`
*(Covers FR42)*

**Given** directories are created on startup
**When** any directory is created
**Then** a log entry is emitted: `{"event": "directory_created", "path": "..."}`
*(Covers FR43)*

**Given** directories already exist
**When** the API server starts
**Then** no errors occur and no creation logs are emitted

**Given** directory creation fails (permissions issue)
**When** startup encounters the error
**Then** a clear error is logged and startup fails gracefully

---

### Story 9.3: Mod Cache Eviction Strategy

As an **administrator**,
I want **the mod cache to automatically clean up old files**,
So that **disk space is managed without manual intervention**.

**Acceptance Criteria:**

**Given** the mod cache directory exists
**When** total cache size exceeds the configured limit (default 500MB)
**Then** the oldest accessed files are evicted until under limit (LRU strategy)
*(Covers FR44)*

**Given** I set `VS_MOD_CACHE_MAX_SIZE` environment variable
**When** the API server starts
**Then** the cache limit is set to the configured value
*(Covers FR45)*

**Given** cache eviction occurs
**When** files are removed
**Then** log entries are emitted: `{"event": "cache_evicted", "file": "...", "reason": "size_limit"}`
*(Covers FR46)*

**Given** the cache is under the size limit
**When** eviction check runs
**Then** no files are removed

---

### Story 9.4: Debug Logging Infrastructure

As a **developer or operator**,
I want **comprehensive debug logging throughout the API**,
So that **I can troubleshoot issues with detailed request tracing**.

**Acceptance Criteria:**

**Given** `VS_DEBUG=true` is set
**When** API requests are processed
**Then** debug-level logs are emitted for each service layer (router → service → repository)
*(Covers FR47)*

**Given** `VS_DEBUG` is changed at runtime
**When** the environment variable is updated
**Then** debug logging is enabled/disabled without server restart
*(Covers FR48)*

**Given** debug logging is enabled
**When** a request is processed
**Then** all log entries include a correlation ID (`request_id`) for tracing
**And** the correlation ID is consistent across all logs for that request
*(Covers FR49)*

**Given** debug logging is disabled (default)
**When** requests are processed
**Then** only info, warning, and error logs are emitted

---

### Story 9.5: Console Command Highlighting

As an **administrator**,
I want **my commands to be visually distinct in the console**,
So that **I can easily identify what I typed vs server output**.

**Acceptance Criteria:**

**Given** I send a command via the console
**When** the command is echoed in the terminal
**Then** it is displayed in a distinct color (e.g., cyan or yellow)
*(Covers FR50)*

**Given** I send a command via the console
**When** the command appears in the output
**Then** it is prefixed with `[CMD]` marker
*(Covers FR51)*

**Given** server output arrives
**When** it is displayed in the terminal
**Then** it uses the default console color (not the command color)

---

### Story 9.6: JSON Syntax Colorization

As an **administrator**,
I want **JSON files to be syntax-highlighted in the file viewer**,
So that **configuration files are easier to read and understand**.

**Acceptance Criteria:**

**Given** I open a `.json` file in the file viewer
**When** the content is rendered
**Then** syntax colorization is applied
*(Covers FR52)*

**Given** JSON content is displayed
**When** I view the highlighted content
**Then** keys, strings, numbers, booleans, and null values each have distinct colors
*(Covers FR53)*

**Given** I open a non-JSON file
**When** the content is rendered
**Then** no JSON colorization is applied (plain text)

**Given** the JSON file contains invalid JSON
**When** the file is displayed
**Then** it renders as plain text with no colorization errors

---

### Story 9.7: Dynamic File Browser

As an **administrator**,
I want **the file browser to show all directories dynamically**,
So that **I can access ModConfigs, Macros, Playerdata, and other directories**.

**Acceptance Criteria:**

**Given** I open the file browser
**When** the directory listing loads
**Then** all directories under `/data/serverdata/` are displayed
**And** this includes ModConfigs, Macros, Playerdata, and any others present
*(Covers FR54)*

**Given** the file browser lists directories
**When** the list is generated
**Then** it is dynamically discovered from the filesystem (not hardcoded)
*(Covers FR55)*

**Given** a new directory is created in `/data/serverdata/`
**When** I refresh the file browser
**Then** the new directory appears in the listing

---

## Epic 10: Advanced Mod Browser

Admins can discover and install mods through a full-featured browser with search, filters, and sorting - matching the experience of mods.vintagestory.at directly within the management UI.

**FRs covered:** FR56, FR57, FR58, FR59, FR60, FR61, FR62, FR63, FR64, FR65, FR66, FR67, FR68, FR69, FR70, FR71, FR72, FR73, FR74, FR75, FR76, FR77, FR78, FR79, FR80, FR81, FR82, FR83, FR84, FR85

**MVP Scope:**

- Split Mods view into Installed/Browse tabs
- Smart landing page with newest mods, pre-filtered to game version
- Keyword search with debounce
- Filters: side, tags, game version, mod type
- Sorting: newest, downloads, updated, trending, name
- Card display with thumbnails and compatibility badges
- Mod detail view with install/update actions
- Pagination for large result sets
- Direct install from browse results

---

### Story 10.1: Mod Browse API

As a **frontend developer**,
I want **an API endpoint that searches and filters the mod database**,
So that **the browse UI can display mods with all filtering and sorting options**.

**Acceptance Criteria:**

**Given** I call `GET /api/v1alpha1/mods/browse`
**When** no parameters are provided
**Then** I receive the newest mods, pre-filtered to the current game server version
**And** the response includes pagination metadata (total, page, per_page)
*(Covers FR59, FR60, FR61)*

**Given** I call `GET /api/v1alpha1/mods/browse?q=magic`
**When** the search parameter is provided
**Then** results are filtered to mods matching "magic" in name or description
*(Covers FR62)*

**Given** I call with filter parameters
**When** I include `side=server`, `tags=qol,utility`, `version=1.21`, `type=code`
**Then** results are filtered by all specified criteria (AND logic)
*(Covers FR65, FR66, FR67, FR68, FR69)*

**Given** I call with sort parameter
**When** I include `sort=downloads` (or `newest`, `updated`, `trending`, `name`)
**Then** results are sorted accordingly
*(Covers FR71, FR72, FR73)*

**Given** I call with pagination parameters
**When** I include `page=2&per_page=20`
**Then** I receive the second page of 20 results
**And** response includes `total_count` for pagination UI
*(Covers FR80)*

**Given** the VintageStory mod API is unavailable
**When** I attempt to browse mods
**Then** I receive cached data if available, or a clear error message
*(Covers NFR11)*

---

### Story 10.2: Mods Tab Restructure

As an **administrator**,
I want **the Mods page split into Installed and Browse tabs**,
So that **I can manage installed mods separately from discovering new ones**.

**Acceptance Criteria:**

**Given** I navigate to the Mods page
**When** the page loads
**Then** I see two tabs: "Installed" and "Browse"
**And** "Installed" is the default active tab
*(Covers FR56)*

**Given** I click the "Installed" tab
**When** the tab activates
**Then** I see the existing mod management UI (list, enable, disable, remove, update)
*(Covers FR57)*

**Given** I click the "Browse" tab
**When** the tab activates
**Then** I see the new mod discovery interface
*(Covers FR58)*

**Given** I am on either tab
**When** I switch tabs
**Then** the URL updates to reflect the active tab (e.g., `/mods/installed`, `/mods/browse`)
**And** browser back/forward navigation works correctly

---

### Story 10.3: Browse Landing Page & Search

As an **administrator**,
I want **the Browse tab to show newest mods immediately with search capability**,
So that **I can discover mods without having to search first**.

**Acceptance Criteria:**

**Given** I navigate to the Browse tab
**When** the page loads
**Then** newest mods are displayed immediately (no user action required)
**And** results are pre-filtered to my game server version
*(Covers FR59, FR60, FR61)*

**Given** I see the Browse interface
**When** I look at the top of the page
**Then** I see a search input field

**Given** I type in the search field
**When** I stop typing (300ms debounce)
**Then** search results update automatically
*(Covers FR62, FR63)*

**Given** I have filters or sort applied
**When** I perform a search
**Then** the search respects existing filter and sort selections
*(Covers FR64)*

**Given** the search field has text
**When** I click a clear button or press Escape
**Then** the search is cleared and results return to default (newest)

---

### Story 10.4: Filter & Sort Controls

As an **administrator**,
I want **to filter and sort mod results**,
So that **I can find specific types of mods quickly**.

**Acceptance Criteria:**

**Given** I am on the Browse tab
**When** I view the filter controls
**Then** I see filter options for: Side, Tags, Game Version, Mod Type

**Given** I select a Side filter
**When** I choose "Server-only"
**Then** results update to show only server-side mods
*(Covers FR65)*

**Given** I select Tags
**When** I choose multiple tags (e.g., "QoL", "Utility")
**Then** results show mods matching ANY selected tag
*(Covers FR66)*

**Given** I select a Game Version filter
**When** I choose a specific version
**Then** results show mods compatible with that version
*(Covers FR67)*

**Given** I select a Mod Type filter
**When** I choose "Code Mod"
**Then** results show only code mods
*(Covers FR68)*

**Given** I have multiple filters active
**When** results are displayed
**Then** all filters are applied together (AND logic)
*(Covers FR69)*

**Given** filters are active
**When** I view the filter area
**Then** active filters are displayed as chips/badges that can be individually removed
*(Covers FR70)*

**Given** I view the sort dropdown
**When** I select a sort option (Newest, Downloads, Updated, Trending, Name)
**Then** results are re-sorted accordingly
*(Covers FR71)*

**Given** I haven't changed the sort
**When** browsing mods
**Then** the default sort is "Newest"
*(Covers FR72)*

**Given** I change the sort option
**When** I navigate within the browse experience
**Then** my sort selection persists
*(Covers FR73)*

---

### Story 10.5: Mod Card Display

As an **administrator**,
I want **mods displayed as informative cards**,
So that **I can quickly scan and evaluate mods**.

**Acceptance Criteria:**

**Given** browse results are displayed
**When** I view the mod grid/list
**Then** each mod shows: thumbnail image (or placeholder), name, author, download count, short description
*(Covers FR74)*

**Given** a mod card is displayed
**When** I view the compatibility indicator
**Then** I see a badge showing compatibility with my game server version (Compatible/Not verified/Incompatible)
*(Covers FR75)*

**Given** I see a mod card
**When** I click anywhere on the card
**Then** I navigate to the mod detail view
*(Covers FR76)*

**Given** mods have no thumbnail
**When** the card is rendered
**Then** a placeholder image is displayed

---

### Story 10.6: Mod Detail View

As an **administrator**,
I want **a detailed view of any mod**,
So that **I can read full information before installing**.

**Acceptance Criteria:**

**Given** I click a mod card
**When** the detail view opens
**Then** I see: full description (rendered markdown), all releases, dependencies, compatibility information
*(Covers FR77)*

**Given** I am viewing mod details
**When** I look at the install section
**Then** I see an "Install" button with a version dropdown to select which release
*(Covers FR78)*

**Given** the mod is already installed
**When** I view the detail page
**Then** I see "Installed: v1.2.3" indicator
**And** if an update is available, I see an "Update to v1.3.0" button
*(Covers FR79)*

**Given** I am on the detail view
**When** I click the back button or breadcrumb
**Then** I return to the browse results at the same position

---

### Story 10.7: Pagination

As an **administrator**,
I want **pagination for large result sets**,
So that **I can browse through thousands of mods efficiently**.

**Acceptance Criteria:**

**Given** browse results exceed one page
**When** results are displayed
**Then** pagination controls are visible (page numbers or "Load more" button)
*(Covers FR80)*

**Given** the UI implements infinite scroll
**When** I scroll to the bottom of the results
**Then** the next page of results loads automatically
*(Covers FR81 - Option A)*

**Given** the UI implements page controls
**When** I click page 2
**Then** page 2 results are displayed
*(Covers FR81 - Option B)*

**Given** I am on page 3 of results
**When** I click a mod card, view details, then go back
**Then** I return to page 3 at approximately the same scroll position
*(Covers FR82)*

---

### Story 10.8: Browse Install Integration

As an **administrator**,
I want **to install mods directly from the browser**,
So that **discovery and installation is a seamless experience**.

**Acceptance Criteria:**

**Given** I am viewing a mod card or detail view
**When** I click "Install"
**Then** an install confirmation dialog appears
*(Covers FR83)*

**Given** the install dialog is open
**When** I view the dialog
**Then** I see the compatibility check result (Compatible/Not verified/Incompatible)
**And** a warning is shown if not verified or incompatible
*(Covers FR84)*

**Given** I confirm installation
**When** the install completes successfully
**Then** a success toast appears
**And** the mod card/detail updates to show "Installed"
**And** the mod appears in the Installed tab
*(Covers FR85)*

**Given** I install a mod from the browse view
**When** I switch to the Installed tab
**Then** the newly installed mod is visible in the list

**Given** installation fails
**When** the error occurs
**Then** a clear error message is displayed
**And** the install button returns to its original state
